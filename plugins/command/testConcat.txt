import re

from plugins import plugin
import globalv

__version__ = '0.2.0'

cs_re = re.compile(r',\s+')
bks_re = re.compile(r'\[[0-9a-z]{2}\]')
prs_re = re.compile(r'\([0-9a-z]{2}(?:,[xy]\)|,s\),y|\))?')
jmp6_re = re.compile(r'\[[0-9a-z]{6}\]')
jmp4_re = re.compile(r'\([0-9a-z]{4}(?:,x)?\)')
label_re = re.compile(r'([\w\d]+):')
splitup_re = re.compile(r'..')

class pluginClass(plugin):

    def asm(self, token, tokens, labels):
        m = label_re.match(token)
        if m is not None:
            labels[m.group(1)] = len(tokens)
            token = token.split(None, 1)[1]
        del m
        L = cs_re.sub(',', token).split()
        insn = L[0]
        if insn == 'db' or insn == 'data':
            return reduce(lambda x, y: x + y, [self.splitup(i) for i in L[1:]])
        if len(L) == 1:
            if insn == 'inx':
                return ['E8']
            if insn == 'iny':
                return ['C8']
            if insn == 'dex':
                return ['CA']
            if insn == 'dey':
                return ['88']
            if insn == 'pla':
                return ['68']
            if insn == 'plx':
                return ['FA']
            if insn == 'ply':
                return ['7A']
            if insn == 'pld':
                return ['2B']
            if insn == 'plb':
                return ['AB']
            if insn == 'plp':
                return ['28']
            if insn == 'tax':
                return ['AA']
            if insn == 'tay':
                return ['A8']
            if insn == 'tcs':
                return ['1B']
            if insn == 'tcd':
                return ['5B']
            if insn == 'txa':
                return ['8A']
            if insn == 'txy':
                return ['9B']
            if insn == 'txs':
                return ['9A']
            if insn == 'tya':
                return ['98']
            if insn == 'tyx':
                return ['BB']
            if insn == 'tsc':
                return ['3B']
            if insn == 'tsx':
                return ['BA']
            if insn == 'tdc':
                return ['7B']
            if insn == 'xba':
                return ['EB']
            if insn == 'clc':
                return ['18']
            if insn == 'cld':
                return ['D8']
            if insn == 'cli':
                return ['58']
            if insn == 'clv':
                return ['B8']
            if insn == 'sec':
                return ['38']
            if insn == 'sed':
                return ['F8']
            if insn == 'sei':
                return ['78']
            if insn == 'xce':
                return ['FB']
            if insn == 'nop':
                return ['EA']
            if insn == 'wdm':
                return ['42']
            if insn == 'rti':
                return ['40']
            if insn == 'rts':
                return ['60']
            if insn == 'rtl':
                return ['6B']
            if insn == 'wai':
                return ['CB']
            if insn == 'stp':
                return ['DB']
            if insn == 'pha':
                return ['48']
            if insn == 'php':
                return ['08']
            if insn == 'phx':
                return ['DA']
            if insn == 'phy':
                return ['5A']
            if insn == 'phb':
                return ['8B']
            if insn == 'phd':
                return ['0B']
            if insn == 'phk':
                return ['4B']
        if len(L) == 2:
            op = L[1]
            if insn == 'adc':
                if op[0] == '#':
                    return ['69'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['77', op[1:3]]
                    return ['67', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['73', op[1:3]]
                    if op.endswith(',x)'):
                        return ['61', op[1:3]]
                    if op.endswith(',y)'):
                        return ['71', op[1:3]]
                    return ['72', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['75', b[0]]
                    if len(b) == 2:
                        return ['7D'] + b
                    if len(b) == 3:
                        return ['7F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['79'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['63'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['65', b[0]]
                if len(op) == 2:
                    return ['6D'] + b
                if len(op) == 3:
                    return ['6F'] + b
                return [None]
            if insn == 'inc':
                if op == 'a':
                    return ['1A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['F6', op[:2]]
                    if len(op) == 6:
                        return ['FE'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['E6', op]
                if len(op) == 4:
                    return ['EE'] + self.splitup(op)
                return [None]
            if insn == 'sbc':
                if op[0] == '#':
                    return ['E9'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['F7', op[1:3]]
                    return ['E7', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['F3', op[1:3]]
                    if op.endswith(',x)'):
                        return ['E1', op[1:3]]
                    if op.endswith(',y)'):
                        return ['F1', op[1:3]]
                    return ['F2', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['F5', b[0]]
                    if len(b) == 2:
                        return ['FD'] + b
                    if len(b) == 3:
                        return ['FF'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['F9'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['E3'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['E5', b[0]]
                if len(op) == 2:
                    return ['ED'] + b
                if len(op) == 3:
                    return ['EF'] + b
                return [None]
            if insn == 'cmp':
                if op[0] == '#':
                    return ['C9'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['D7', op[1:3]]
                    return ['C7', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['D3', op[1:3]]
                    if op.endswith(',x)'):
                        return ['C1', op[1:3]]
                    if op.endswith(',y)'):
                        return ['D1', op[1:3]]
                    return ['D2', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['D5', b[0]]
                    if len(b) == 2:
                        return ['DD'] + b
                    if len(b) == 3:
                        return ['DF'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['D9'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['C3'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['C5', b[0]]
                if len(op) == 2:
                    return ['CD'] + b
                if len(op) == 3:
                    return ['CF'] + b
                return [None]
            if insn == 'cpx':
                if op[0] == '#':
                    return ['E0'] + self.splitup(op[1:])
                if len(op) == 2:
                    return ['E4', op]
                if len(op) == 4:
                    return ['EC'] + self.splitup(op)
                return [None]
            if insn == 'cpy':
                if op[0] == '#':
                    return ['C0'] + self.splitup(op[1:])
                if len(op) == 2:
                    return ['C4', op]
                if len(op) == 4:
                    return ['CC'] + self.splitup(op)
                return [None]
            if insn == 'dec':
                if op == 'a':
                    return ['3A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['D6', op[:2]]
                    if len(op) == 6:
                        return ['DE'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['C6', op]
                if len(op) == 4:
                    return ['CE'] + self.splitup(op)
                return [None]
            if insn == 'lda':
                if op[0] == '#':
                    return ['A9'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['B7', op[1:3]]
                    return ['A7', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['B3', op[1:3]]
                    if op.endswith(',x)'):
                        return ['A1', op[1:3]]
                    if op.endswith(',y)'):
                        return ['B1', op[1:3]]
                    return ['B2', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['B5', b[0]]
                    if len(b) == 2:
                        return ['BD'] + b
                    if len(b) == 3:
                        return ['BF'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['B9'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['A3'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['A5', b[0]]
                if len(op) == 2:
                    return ['AD'] + b
                if len(op) == 3:
                    return ['AF'] + b
                return [None]
            if insn == 'ldx':
                if op[0] == '#':
                    return ['A2'] + self.splitup(op[1:])
                if len(op) == 2:
                    return ['A6', op]
                if len(op) == 4:
                    return ['AE'] + self.splitup(op)
                return [None]
            if insn == 'ldy':
                if op[0] == '#':
                    return ['A0'] + self.splitup(op[1:])
                if len(op) == 2:
                    return ['A4', op]
                if len(op) == 4:
                    return ['AC'] + self.splitup(op)
                return [None]
            if insn == 'ora':
                if op[0] == '#':
                    return ['09'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['17', op[1:3]]
                    return ['07', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['13', op[1:3]]
                    if op.endswith(',x)'):
                        return ['01', op[1:3]]
                    if op.endswith(',y)'):
                        return ['11', op[1:3]]
                    return ['12', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['15', b[0]]
                    if len(b) == 2:
                        return ['1D'] + b
                    if len(b) == 3:
                        return ['1F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['19'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['03'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['05', b[0]]
                if len(op) == 2:
                    return ['0D'] + b
                if len(op) == 3:
                    return ['0F'] + b
                return [None]
            if insn == 'and':
                if op[0] == '#':
                    return ['29'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['37', op[1:3]]
                    return ['27', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['33', op[1:3]]
                    if op.endswith(',x)'):
                        return ['21', op[1:3]]
                    if op.endswith(',y)'):
                        return ['31', op[1:3]]
                    return ['32', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['35', b[0]]
                    if len(b) == 2:
                        return ['3D'] + b
                    if len(b) == 3:
                        return ['3F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['39'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['23'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['25', b[0]]
                if len(op) == 2:
                    return ['2D'] + b
                if len(op) == 3:
                    return ['2F'] + b
                return [None]
            if insn == 'bit':
                if op[0] == '#':
                    return ['89'] + self.splitup(op[1:])
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['34', op[:2]]
                    if len(op) == 6:
                        return ['3C'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['24', op]
                if len(op) == 4:
                    return ['2C'] + self.splitup(op)
                return [None]
            if insn == 'eor':
                if op[0] == '#':
                    return ['49'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['57', op[1:3]]
                    return ['47', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['53', op[1:3]]
                    if op.endswith(',x)'):
                        return ['41', op[1:3]]
                    if op.endswith(',y)'):
                        return ['51', op[1:3]]
                    return ['52', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['55', b[0]]
                    if len(b) == 2:
                        return ['5D'] + b
                    if len(b) == 3:
                        return ['5F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['59'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['43'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['45', b[0]]
                if len(op) == 2:
                    return ['4D'] + b
                if len(op) == 3:
                    return ['4F'] + b
                return [None]
            if insn == 'asl':
                if op == 'a':
                    return ['0A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['16', op[:2]]
                    if len(op) == 6:
                        return ['1E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['06', op]
                if len(op) == 4:
                    return ['0E'] + self.splitup(op)
                return [None]
            if insn == 'rol':
                if op == 'a':
                    return ['2A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['36', op[:2]]
                    if len(op) == 6:
                        return ['3E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['26', op]
                if len(op) == 4:
                    return ['2E'] + self.splitup(op)
                return [None]
            if insn == 'lsr':
                if op == 'a':
                    return ['4A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['56', op[:2]]
                    if len(op) == 6:
                        return ['5E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['46', op]
                if len(op) == 4:
                    return ['4E'] + self.splitup(op)
                return [None]
            if insn == 'ror':
                if op == 'a':
                    return ['6A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['76', op[:2]]
                    if len(op) == 6:
                        return ['7E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['66', op]
                if len(op) == 4:
                    return ['6E'] + self.splitup(op)
                return [None]
            if insn == 'sep':
                if op[0] == '#':
                    return ['E2', op[1:3]]
                return [None]
            if insn == 'rep':
                if op[0] == '#':
                    return ['C2', op[1:3]]
                return [None]
            if insn == 'jmp':
                if jmp6_re.match(op):
                    return ['DC'] + self.splitup(op[1:-1])
                if jpm4_re.match(op):
                    if op.endswith(',x)'):
                        return ['7C'] + self.splitup(op[1:5])
                    return ['6C'] + self.splitup(op[1:5])
                if len(op) == 4:
                    return ['4C'] + self.splitup(op)
                if len(op) == 6:
                    return ['5C'] + self.splitup(op)
                return [None]
            if insn == 'jml':
                return ['5C'] + self.splitup(op)
            if insn == 'jsr':
                if insn.startswith('(') and insn.endswith(',x)'):
                    return ['FC'] + self.splitup(op[1:5])
                if len(insn) == 4:
                    return ['20'] + self.splitup(op)
                if len(insn) == 6:
                    return ['22'] + self.splitup(op)
                return [None]
            if insn == 'jsl':
                return ['22'] + self.splitup(op)
            if insn == 'bra':
                if op in labels:
                    return ['label ' + token, '']
                if len(op) == 2:
                    return ['80', op]
                return [None]
            if insn == 'brl':
                if op in labels:
                    return ['label ' + token, '', '']
                return ['82'] + self.splitup(op)
            if insn == 'bcc':
                if op in labels:
                    return ['label ' + token, '']
                return ['90', op]
            if insn == 'bcs':
                if op in labels:
                    return ['label ' + token, '']
                return ['B0', op]
            if insn == 'beq':
                if op in labels:
                    return ['label ' + token, '']
                return ['F0', op]
            if insn == 'bne':
                if op in labels:
                    return ['label ' + token, '']
                return ['D0', op]
            if insn == 'bmi':
                if op in labels:
                    return ['label ' + token, '']
                return ['30', op]
            if insn == 'bpl':
                if op in labels:
                    return ['label ' + token, '']
                return ['10', op]
            if insn == 'bvc':
                if op in labels:
                    return ['label ' + token, '']
                return ['50', op]
            if insn == 'bvs':
                if op in labels:
                    return ['label ' + token, '']
                return ['70', op]
            if insn == 'sta':
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['97', op[1:3]]
                    return ['87', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['93', op[1:3]]
                    if op.endswith(',x)'):
                        return ['81', op[1:3]]
                    if op.endswith(',y)'):
                        return ['91', op[1:3]]
                    return ['92', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['95', b[0]]
                    if len(b) == 2:
                        return ['9D'] + b
                    if len(b) == 3:
                        return ['9F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['99'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['83'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['85', b[0]]
                if len(op) == 2:
                    return ['8D'] + b
                if len(op) == 3:
                    return ['8F'] + b
                return [None]
            if insn == 'stx':
                if op.endswith(',y'):
                    return ['96', op[:2]]
                if len(op) == 2:
                    return ['86', op]
                if len(op) == 4:
                    return ['8E'] + self.splitup(op)
                return [None]
            if insn == 'sty':
                if op.endswith(',x'):
                    return ['94', op[:2]]
                if len(op) == 2:
                    return ['84', op]
                if len(op) == 4:
                    return ['8C'] + self.splitup(op)
                return [None]
            if insn == 'stz':
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['74', op[:2]]
                    if len(op) == 6:
                        return ['9E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['64', op]
                if len(op) == 4:
                    return ['9C'] + self.splitup(op)
                return [None]
            if insn == 'tsb':
                if len(op) == 2:
                    return ['04', op]
                if len(op) == 4:
                    return ['0C'] + self.splitup(op)
                return [None]
            if insn == 'trb':
                if len(op) == 2:
                    return ['14', op]
                if len(op) == 4:
                    return ['1C'] + self.splitup(op)
                return [None]
            if insn == 'pea':
                return ['F4'] + self.splitup(op)
            if insn == 'pei':
                return ['D4'] + self.splitup(op)
            if insn == 'per':
                return ['62'] + self.splitup(op)
            return [None]
        if len(L) == 3:
            if insn == 'mvn':
                return ['54', L[2], L[1]]
            if insn == 'mvp':
                return ['44', L[2], L[1]]
            return [None]
        return [None]

    def splitup(self, op):
        return splitup_re.findall('0' + op if len(op) & 1 else op)
    
    def gettype(self):
        return 'command'
    
    def action(self, complete):
        msg = []
        tokens = complete.message().lower().replace('$', '').split(';')
        labels = {}
        for i in xrange(len(tokens)):
            token = tokens[i].strip()
            m = label_re.match(token)
            if m is not None:
                labels[m.group(1)] = None
        for token in tokens:
            token = token.strip()
            asm = self.asm(token, msg, labels)
            if None in asm:
                return ['PRIVMSG $C$ :Error: failed token: ' + token]
            msg+=asm
        for i in xrange(len(msg)):
            token = msg[i]
            if token.startswith('label '):
                subs = tuple(token[6:].split())
                label = labels[subs[1]]
                print 'subs: %r   label: %r   i: %r' % (subs, label, i)
                if subs[0] == 'brl':
                    delta = label - (i + 3)
                    if not (delta &~ 65535):
                        msg[i] = '82'
                        msg[i + 1] = b[0]
                        msg[i + 2] = b[1]
                        continue
                    else:
                        return ['PRIVMSG $C$ :Error: label too far: brl ' +
                                subs[1]]
                delta = label - (i + 2)
                if not (delta &~ 255):
                    b = subs[0] + ' ' + hex(delta & 255)[2:].zfill(2)
                    print repr(b)
                    msg[i:i + 2] = self.asm(b, msg, labels)
                    continue
                else:
                    return ['PRIVMSG $C$ :Error: label too far: %s %s' % subs]
        print 'msg: %r' % msg
        return ['PRIVMSG $C$ :' + (' '.join(msg)).upper()] 
    def describe(self, complete):
        return [
            'PRIVMSG $C$ :65816 Assembler Module version %s' % __version__,
            'PRIVMSG $C$ :Copyright 2011 Branden Brown (a.k.a. zephyrtronium, '
            'uNsane, smlaxy, etc.)',
            "PRIVMSG $C$ :PJBoy's 65816 opcode list was referenced in order "
            'to write this.',
            ]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import random
import settingsHandler
from securityHandler import isAllowed
from userlevelHandler import getLevel
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __init_db_tables__(self, name):
        if settingsHandler.tableExists("'"+name+"'")==False:
            settingsHandler.newTable("'"+name+"'","answer")
            answers=["As I see it, yes","It is certain","It is decidedly so","Most likely","Outlook good","Signs point to yes", "Without a doubt", "Yes", "Yes - definitely","You may rely on it", "Reply hazy, try again","Ask again later", "Better not tell you now","Cannot predict now","Concentrate and ask again","Don't count on it","My reply is no","My sources say no","Outlook not so good","Very doubtful"]
            for answer in answers:
                settingsHandler.writeSetting("'"+name+"'", "answer",answer)
    def __init_answers__(self, complete):
        self.answers=[x[0] for x in settingsHandler.readSetting("'"+complete.cmd()[0]+"'","answer")]
        random.shuffle(self.answers)
    def __level__(self):
        return 0
    def __init__(self):
        self.answers=[]
    def action(self, complete):
        msg=complete.message()
        isElevated=(isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]))
        self.__init_answers__(complete)
        if len(msg.split())>=1:
            cmd=msg.split()[0]
            msg=' '.join(msg.split()[1:])
        else:
            cmd=""
            msg=""
        if cmd=="-add" and isElevated:
            settingsHandler.writeSetting("'"+complete.cmd()[0]+"'","answer",msg)
            toReturn="Added that answer"
            self.__init_answers__(complete)
        elif cmd=="-delete" and isElevated:
            settingsHandler.deleteSetting("'"+complete.cmd()[0]+"'","answer",msg)
            toReturn="Wiped that answer."
            self.__init_answers__(complete)
        elif cmd=="-wipe" and isElevated:
            settingsHandler.dropTable("'"+complete.cmd()[0]+"'")
            settingsHandler.newTable("'"+complete.cmd()[0]+"'","answer")
            toReturn="Answer table wiped!"
            self.__init_answers__(complete)
        elif cmd=="-dump":
            self.__init_answers__(complete)
            return ["PRIVMSG $C$ :[%s]"%', '.join(["'"+x+"'" for x in self.answers])]
        else:
            toReturn=self.answers.pop()
            if complete.message()=="":
                toReturn=toReturn.replace("$1$","$U$")
            else:
                toReturn=toReturn.replace("$1$",complete.message())
        return ["PRIVMSG $C$ :"+toReturn]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
	def gettype(self):
		return "command"
	def action(self, complete):
		msg=complete.message()
		return ["PRIVMSG $C$ :ACTION "+msg.decode('utf-8')+""]
	def describe(self, complete):
		msg=complete.message()
		sender=complete[0].split(' ')
		sender=sender[2]
		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from settingsHandler import readSetting
from pluginHandler import load_plugin, unload_plugin
from aliasHandler import load_alias
from securityHandler import isAllowed
from userlevelHandler import getLevel
import settingsHandler
import globalv
import sys
import shlex
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 150
    def action(self, complete):
        name=complete.message()
        msg="Input Module Loaded Successfully"
        if isAllowed(complete.userMask())<getLevel(complete.cmd()[0]):
            return [""]
        if name.split()[0]=="list":
            return ["PRIVMSG $C$ :"+' '.join(globalv.loadedInputs.keys())]
        elif name.split()[0]=="clean":
            newDict={}
            for plugin in globalv.loadedInputs.keys():
                if globalv.loadedInputs[plugin].isSet()==False:
                    newDict[plugin]=globalv.loadedInputs[plugin]
            globalv.loadedInputs=newDict
            return ["PRIVMSG $C$ :ID list cleaned up manually"]
        elif name.split()[0]=="kickstart":
            globalv.input.startInputDaemons()
            return ["PRIVMSG $C$ :Kickstarted stalling plugins manually"]
        elif name.split()[0]=="reboot":
            definition=settingsHandler.readSetting("'core-input'","definition",where="input='%s'"%name.split()[1])
            print "def"
            x=__import__(str(definition.split()[0]))
            reload(x)
            arguments=str(' '.join(definition.split()[1:]))
            arguments=shlex.split(arguments)
            globalv.loadedInputs[name.split()[1]]=globalv.input.addInputSource(x.asyncInput,tuple(arguments))
            globalv.input.startInputDaemons()
            msg="Rebooting input plugin..."
        elif name.split()[0]=="add":
            name= ' '.join(name.split()[1:])
            try:
                if name.split()[0] in globalv.loadedInputs.keys():
                    if globalv.loadedInputs[name.split()[0]].isSet()==False:
                        raise Exception("An input module with that ID already exists!")
                x=__import__(name.split()[1])
                reload(x)
                arguments=shlex.split(' '.join(name.split()[2:]))
                globalv.loadedInputs[name.split()[0]]=globalv.input.addInputSource(x.asyncInput,tuple(arguments))
                print arguments
                settingsHandler.writeSetting("'core-input'", ["input", "definition"], [name.split()[0], ' '.join(name.split()[1:])])
                globalv.input.startInputDaemons()
            except Exception as detail:
                msg="Load failure: "+str(detail)
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !addInput module!","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!addInput [name] [plugin name] [arguments to plugin]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from aliasHandler import load_alias
from securityHandler import isAllowed
from userlevelHandler import getLevel
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 50
    def action(self, complete):
        msg=complete.message()
        pluginBlacklist=["special"]
        if msg.split()[0] in pluginBlacklist and not (isAllowed(complete.userMask())>=getLevel(complete.cmd()[0])):
            msg=["PRIVMSG $C$ :Restricted plugin!"]
        if msg.split()[0] not in globalv.loadedPlugins.keys():
            try:
                load_alias(msg.split()[0], ' '.join(msg.split()[1:]))
                msg=["PRIVMSG $C$ :Alias successful."]
            except:
                msg=["PRIVMSG $C$ :Alias unsuccessful. Are you sure %s is a valid plugin?"%msg.split()[1]]

        else:
            msg=[]
            message=lambda x:msg.append("PRIVMSG $C$ :"+x)
            message("Alias unsuccessful. Syntax: "+globalv.commandCharacter+"alias [word] [command] [optional arguments]")
            message("Optional Arguments can include $C$, which will expand to the channel name, $U$, which will expand to the username of the person who sends it.")
            message("You can also use $number$ style syntax, where number is a one or two digit number representing the word of the input to take. (As in, $2$ would extract \"hi\" from \"!command hey hi\". Additionally, a + or - after the number can be used to grab all words before or after that word.")
        return msg
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !alias module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!alias [what] [plugin] [arguments]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import urllib
import urllib2
from bitlyServ import bitly
import re
import random

class pluginClass(plugin):
    def __init__(self):
        self.history = []
        
    def gettype(self):
        return "command"

    def action(self, complete):
        tags = complete.message()
            
        query = urllib.urlencode(dict([["tags",tags]]))
        url = "http://safebooru.org/index.php?page=dapi&s=post&q=index&limit=200&"+query

        try:
            req=urllib2.urlopen(url)
        except urllib2.HTTPError as error:
            if '406' in str(error):
                return ["PRIVMSG $C$ :Unacceptable input."]
            return ["PRIVMSG $C$ :Safebooru seems down!"]
            
        content = req.read()
        matches = re.findall(r'file_url="(.+?)"(?:.+?)rating="(?:s|q)" tags="\s?(.+?)\s?" id="(\d+?)"', content)

        if matches == []:
            return ["PRIVMSG $C$ :No pictures found!"]

        w_matches = []
        for match in matches:
            if not match[2] in self.history:
                w_matches.append(match)

        if w_matches == []:
            return ["PRIVMSG $C$ :No new picture found (Compared to the last 60 pictures)"]
        
        match = w_matches[random.randint(0, len(w_matches)-1)]

        self.history.append(match[2])
        self.history = self.history[-60:]

        url = match[0]

        tags = match[1].split(' ')

        total_length = 0
        i = 0
        
        for tag in tags:        
            if total_length + len(tag) > 280:
                tags = tags[:i] + ['...']
                break
            i += 1
            total_length += len(tag)
        tags = ' '.join(tags)
        
        return ["PRIVMSG $C$ :" + bitly(url) + " (tags: " + tags + ")"]
    
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !animu module! See http://safebooru.org/index.php?page=help&topic=cheatsheet for a full list of features.",
                "PRIVMSG $C$ :Example usage:",
                "PRIVMSG $C$ :!animu wallpaper blonde_hair",
                "PRIVMSG $C$ :!animu touhou ribbon wings"]
# -*- coding: utf-8 -*-
from plugins import pluginimport osimport globalvclass pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()		pluginList=[]		for line in open(os.path.join("config","autoloading.txt")):			pluginList.append(line.strip())		msg="Autoloading plugins: "+', '.join(pluginList)		return ["PRIVMSG $C$ :"+msg]	def describe(self, complete):		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
from userlevelHandler import getLevel
import os
from securityHandler import isAllowed
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 150
    def action(self, complete):
        msg=complete.message()
        sender=complete.userMask()
        if len(msg.split())>1:
            mode=msg.split()[1].lower()
        else:
            mode="on"
        msg=msg.split()[0]
        print sender
        if isAllowed(sender)>=getLevel(complete.cmd()[0]):
            if mode=="on":
                with open(os.path.join("config","autoloading.txt"),"a") as file:
                    file.write("\n"+msg)
                    return ["PRIVMSG $C$ :Plugin set to autoload, cap'n"]
            else:
                with open(os.path.join("config","autoloading.txt"),"r") as file:
                    lines=file.read().split('\n')
                    print lines
                    lines.remove(msg)
                    with open(os.path.join("config","autoloading.txt"),"w") as file:
                        file.write('\n'.join(lines))
                        return ["PRIVMSG $C$ :Plugin removed from autoloading, cap'n"]
            if msg=="list":
                pluginList=[]
                for line in open(os.path.join("config","autoloading.txt")):
                    pluginList.append(line.strip())
                    msg="Autoloading plugins: "+', '.join(pluginList)
                    return ["PRIVMSG $C$ :"+msg]
            return ["PRIVMSG $C$ :You do not have the required access rights!"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !autoload module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!autoload [plugin] [on/off]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import urllib
import urllib2
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        message=complete.message()
        url="http://64digits.com/index.php?cmd=banner&submit=true"
        data={'b_message':message}
        encoded=urllib.urlencode(data)
        urllib2.urlopen(url, encoded).read()
        return ["PRIVMSG $C$ :Sent that request."]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
from userlevelHandler import getLevel
from securityHandler import isAllowed
import re
import settingsHandler
class pluginClass(plugin):
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name, "kickAfterBan")
        settingsHandler.writeSetting(name, "kickAfterBan", "False")
    def gettype(self):
        return "command"
    def __level__(self):
        return 100
    def action(self, complete):
        msg=complete.message().split()[0]
        kickReason=' '.join(complete.message().split()[1:])
        if kickReason=="":
            kickReason="Go Away."
        if isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]):
            if msg in globalv.miscVars[0].keys():
                hostmask=globalv.miscVars[0][msg]
            print hostmask
            toReturn=['MODE $C$ +b '+hostmask]
            if settingsHandler.readSetting(complete.cmd()[0], "kickAfterBan")=="True":
                toReturn.append("KICK $C$ "+msg+" :"+kickReason)
            return toReturn
        else:
            print "ID failure:",msg,"not in",globalv.miscVars[0][msg]
            return [""]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !ban module. I banish people.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!ban [user] (hostmasks stored locally)"]

from plugins import plugin
import globalv
import random
class pluginClass(plugin):
    def __init__(self):
        self.battleOver = False;
        self.battleTurn = 0;
        self.battleP1 = "Player1";
        self.battleP2 = "Player2";
        self.battleP1HP = random.randrange(60,100);
        self.battleP2HP = random.randrange(60,100);
        self.battleP1MP = random.randrange(10,40);
        self.battleP2MP = random.randrange(10,40);
        self.battleP1ATK = random.randrange(10,20);
        self.battleP2ATK = random.randrange(10,20);
        self.battleP1DEF = random.randrange(5,10);
        self.battleP2DEF = random.randrange(5,10);
        self.battleP1SPD = random.randrange(10,30);
        self.battleP2SPD = random.randrange(10,30);

        self.battleSpell1Name = "Cure";
        self.battleSpell1MP = 5;
        self.battleSpell1Effect = 1;
        # 0 = attack, 1 = heal, 2 = buff attack, 3 = buff defense
        self.battleSpell1Value = 25;

        self.battleSpell2Name = "Fire";
        self.battleSpell2MP = 5;
        self.battleSpell2Effect = 0;
        self.battleSpell2Value = random.randrange(30,40);

        if self.battleP1SPD >= self.battleP2SPD:
            self.battleTurn = 0;
        else :
            self.battleTurn = 1;

        self.lastCommand = "nothing";
        
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()

        if msg == "reset":
            self.__init__();
            return ["PRIVMSG $C$ :"+"!battle reset by $U$"]
        
        if msg == "name1":
            self.lastCommand = "name1";
            return ["PRIVMSG $C$ :"+"Name Player 1:"]
        
        if self.lastCommand == "name1":
            self.battleP1 = msg;
            self.lastCommand = "nothing";
            return ["PRIVMSG $C$ :"+"Player 1 is now known as "+self.battleP1]
        
        if msg == "name2":
            self.lastCommand = "name2";
            return ["PRIVMSG $C$ :"+"Name Player 2:"]

        if self.lastCommand == "name2":
            self.battleP2 = msg;
            self.lastCommand = "nothing";
            return ["PRIVMSG $C$ :"+"Player 2 is now known as "+self.battleP2]

        if msg == "stats1":
            return ["PRIVMSG $U$ : Player 1 stats:","PRIVMSG $U$ : HP: "+str(self.battleP1HP),"PRIVMSG $U$ : MP: "+str(self.battleP1MP),"PRIVMSG $U$ : ATK: "+str(self.battleP1ATK), "PRIVMSG $U$ : DEF: "+str(self.battleP1DEF),"PRIVMSG $U$ : SPD: "+str(self.battleP1SPD)] 

        if msg == "stats2":
            return ["PRIVMSG $U$ : Player 2 stats:","PRIVMSG $U$ : HP: "+str(self.battleP2HP),"PRIVMSG $U$ : MP: "+str(self.battleP2MP),"PRIVMSG $U$ : ATK: "+str(self.battleP2ATK), "PRIVMSG $U$ : DEF: "+str(self.battleP2DEF),"PRIVMSG $U$ : SPD: "+str(self.battleP2SPD)] 

        if msg == "turn":
            if self.battleTurn == 0:
                return ["PRIVMSG $C$ : It is "+self.battleP1+"'s turn..."]
            else :
                return ["PRIVMSG $C$ : It is "+self.battleP2+"'s turn..."]

        if msg == "fight":
            self.finalMsg = "";
            self.damageDone = 0;

            if self.battleP1HP <= 0 :
                self.battleTurn = 2;
                self.XP = self.battleP1DEF*self.battleP1ATK;
                self.GP = self.battleP1DEF+self.battleP1ATK;
                return ["PRIVMSG $C$ : "+self.battleP2+" won the battle!", "PRIVMSG $C$ : "+self.battleP2+" gets "+str(self.XP)+" XP and "+str(self.GP)+" GP!"]

            if self.battleP2HP <= 0 :
                self.battleTurn = 2;
                self.XP = self.battleP2DEF*self.battleP2ATK;
                self.GP = self.battleP2DEF+self.battleP2ATK;
                return ["PRIVMSG $C$ : "+self.battleP1+" won the battle!", "PRIVMSG $C$ : "+self.battleP1+" gets "+str(self.XP)+" XP and "+str(self.GP)+" GP!"]

            if self.battleTurn == 2:
                return ["PRIVMSG $C$: The battle has ended. Please reset the battle by using !battle reset"]
            
            if self.battleTurn == 0  and self.battleP2HP > 0:
                self.damageDone = self.battleP1ATK - self.battleP2DEF + random.randrange(0,self.battleP1ATK);
                self.battleP2HP -= self.damageDone;
                if self.battleP2HP <= 0: self.battleP2HP = 0;
                self.battleTurn = 1;
                return ["PRIVMSG $C$ : "+self.battleP1+" "+random.choice(["whacks","slices","smashes","slices","jabs","attacks"])+" "+self.battleP2+" with his weapon!","PRIVMSG $C$ : "+self.battleP2+" loses "+str(self.damageDone)+"HP!", "PRIVMSG $C$ : "+self.battleP1+" has "+str(self.battleP1HP)+" HP left.","PRIVMSG $C$ : "+self.battleP2+" has "+str(self.battleP2HP)+" HP left."];
            
            if self.battleTurn == 1 and self.battleP2HP > 0:
                self.damageDone = self.battleP2ATK - self.battleP1DEF + random.randrange(0,self.battleP2ATK);
                self.battleP1HP -= self.damageDone;
                if self.battleP1HP <= 0: self.battleP1HP = 0;
                self.battleTurn = 0;
                return ["PRIVMSG $C$ : "+self.battleP2+" "+random.choice(["whacks","slices","smashes","slices","jabs","attacks"])+" "+self.battleP1+" with his weapon!","PRIVMSG $C$ : "+self.battleP1+" loses "+str(self.damageDone)+"HP!", "PRIVMSG $C$ : "+self.battleP1+" has "+str(self.battleP1HP)+" HP left.","PRIVMSG $C$ : "+self.battleP2+" has "+str(self.battleP2HP)+" HP left."];

            
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !battle module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!battle reset|name1|name2|stats1|stats2|fight|spell1|spell2|status|spellList"]
# -*- coding: utf-8 -*-
from plugins import plugin
from bitlyServ import bitlyimport globalv,reclass pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()
		if re.match("https?://.*",msg)==None:
			msg="http://"+msg		return ["PRIVMSG $C$ :"+bitly(msg)]	def describe(self, complete):		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]# -*- coding: utf-8 -*-
from __future__ import division
import globalv
from plugins import plugin
from math import *
import urllib
import multiprocessing
import time
import WordScramble
from random import random, randint, shuffle
import ast
import re
finished=False
safe_list = ['random','math','acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'cosh', 'de grees', 'e', 'exp', 'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log', 'log10', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh','int','bin','oct','hex'] #use the list to filter the local namespace 
safe_dict = dict([ (k, locals().get(k, None)) for k in safe_list ]) #add any needed builtins back in.
safe_dict['abs'] = abs 
reload(WordScramble)
safe_dict['scramble']=WordScramble.scramble
safe_dict['hex']=hex
safe_dict['int']=int
safe_dict['oct']=oct
safe_dict['bin']=bin
safe_dict['len']=len
safe_dict['chr']=chr
safe_dict['True']=True
safe_dict['False']=False
safe_dict['randint']=randint
safe_dict['reduce']=reduce
safe_dict['factorial']=factorial
safe_dict['set']=set
safe_dict['str']=str
safe_dict['sorted']=sorted
safe_dict['sum']=sum
safe_dict['range']=xrange
safe_dict['urlescape']=urllib.quote
def notInPlaceShuffle(list):
    shuffle(list)
    return list
def int2base(x,b,alphabet='0123456789abcdefghijklmnopqrstuvwxyz'):
    'convert an integer to its string representation in a given base'
    #Credit to Mark Borgerding
    if b<2 or b>len(alphabet):
        if b==64: # assume base64 rather than raise error
            alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        else:
            raise AssertionError("int2base base out of range")
    if type(x) == complex: # return a tuple
        return ( int2base(x.real,b,alphabet) , int2base(x.imag,b,alphabet) )
    if x<=0:
        if x==0:
            return alphabet[0]
        else:
            return  '-' + int2base(-x,b,alphabet)
    # else x is non-negative real
    rets=''
    while x>0:
        x,idx = divmod(x,b)
        rets = alphabet[idx] + rets
    return rets
primes = [ # list of primes 2 < P <= 1009
        3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,
        83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,
        167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251,
        257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349,
        353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443,
        449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557,
        563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647,
        653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757,
        761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863,
        877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983,
        991, 997, 1009
        ]
def factorize(x):
    '''Return a list of the prime factors of x (including -1 if x is negative).'''
    if not x:
        return [0]
    if x in primes:
        return [x]
    if x < 0:
        a = [-1]
    else:
        a = []
    while not (x & 1):
        a.append(2)
        x >>= 1
    n = 0
    while n < len(primes):
        q, r = divmod(x, primes[n])
        if not r:
            a.append(primes[n])
            x = q
        else:
            n += 1
        c = 1013
        while x > 1:
            q, r = divmod(x, c)
            if not r:
                a.append(c)
                x = q
            else:
                c += 1
                while not isprime(c):
                    c += 1
    return a
def bite(x):
    '''Return a list of the powers of two that sum to x.
    All elements will have the same sign as x.'''
    c = -x if x < 0 else x # Twice as fast as c = abs(x). x >= 0 is faster than x < 0.
    a = []
    n = 1
    while n <= c:
        if c & n: # naive
            a.append(-n if x < 0 else n)
        n <<= 1
    return a if a else [0]
def isprime(x):
    '''Return True if the only unique factors of x are 1 and x.'''
    if x < 2:
        return False
    if x < 4:
        return True
    if not x & 1:
        return False
    if x in primes:
        return True
    if x < 1009:
        return False
    n = 0
    while n < len(primes):
        if not x % primes[n]:
            return False
        n += 1
    m = int(x ** 0.5) + 1 # ceil(sqrt(x))
    c = 1013
    while c < m:
        if not x % c:
            return False
        c += 1
        while not isprime(c): # should help reduce execution time for large numbers
            c += 1
    return True
safe_dict['factorise']=factorize
safe_dict['isprime']=isprime
safe_dict['bite']=bite
safe_dict['factorize']=factorize
safe_dict['int2base']=int2base
safe_dict['shuffle']=notInPlaceShuffle
def convertBitsToFloat(msg):
    allNums=re.findall("[0-9.]*",msg)
    for num in allNums:
        if num!='':
            try:
                msg.replace(num,str(float(num)))
            except:
                pass
    return msg

def evaluate(msg, output):
    newDict = safe_dict.copy()
    newDict.update(globalv.variables)
    output.put(str(eval(msg,{"__builtins__":None},newDict)))

class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        msg=convertBitsToFloat(msg)
        try:
            outputQueue=multiprocessing.Queue()
            calculationThread=multiprocessing.Process(target=evaluate, args=(msg,outputQueue))
            calculationThread.start()
            now=time.time()
            while (time.time()-now)<5:
                time.sleep(0.05)
                if calculationThread.is_alive()==False and outputQueue.empty():
                    raise Exception(msg)
                if outputQueue.empty()==False:
                    msg=outputQueue.get()
                    break
            else:
                calculationThread.terminate()
                raise Exception("Calculation took too long!")
        except Exception as detail:
            msg="Calculation Failure: %s"%detail
        if len(msg)>8000:
            msg="Result far too large!"
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !calculate module! I do maths!","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!calculate [expression]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from pluginArguments import pluginArguments
from pluginFormatter import formatInput, formatOutput
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        output=msg.split('>')[-1]
        if output==msg or len(output.split())!=1:
            output="$C$"
        else:
            msg=msg.split('>')[0]
        commandlist=msg.split('&&')
        returns=[]
        for msg in commandlist:
            msg=msg.replace('\|','__PIPE__')
            commands=msg.split('|')
            commands=map(lambda x: x.replace('__PIPE__','|'), commands)
            pluginOutput=""
            for command in commands:
                plugin=command.split()[0]
                args=' '.join(command.split()[1:])
                if globalv.loadedPlugins[plugin].__append_seperator__()==True:
                    args+="::"
                args+=pluginOutput
                arguments=pluginArguments(complete.complete())
                firstBit=arguments.complete().split(':')[1]
                arguments.setComplete(":"+firstBit+":"+globalv.commandCharacter+plugin+" "+args)
                arguments=formatInput(arguments)
                pluginOutput=globalv.loadedPlugins[plugin].action(arguments)
                if pluginOutput!=[""]:
                    starter=pluginOutput[0].split(':')[0]
                    if starter.split()[0]=="PRIVMSG":
                        content=""
                        pluginOutput=[x for x in pluginOutput if x!=""]
                        for i,line in enumerate(pluginOutput):
                            content+=':'.join(line.split(':')[1:])+(" | " if i!=len(pluginOutput)-1 else "")
                        pluginOutput=starter+(':'+content if content!="" else "")
                        pluginOutput=':'.join(pluginOutput.split(':')[1:]) if command!=commands[-1] else pluginOutput
                else:
                    pluginOutput=""

            if type(pluginOutput)!=list:
                pluginOutput=pluginOutput.replace('$C$', output)
            else:
                pluginOutput=[x.replace('$C$', output) for x in pluginOutput]
            outputstr=formatOutput(pluginOutput,complete)
            if outputstr!="":
                #returns.append(outputstr)
                returns+=outputstr
        return returns
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        print globalv.channelUsers
        names=['"%s"'%name for name in globalv.channelUsers[complete.channel()]]
        return ["PRIVMSG $C$ :[%s]"%', '.join(names)]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
	def gettype(self):
		return "command"
	def action(self, complete):
		return ["PRIVMSG $C$ :"+str(globalv.input.getPrimaryProducerStatus())]
	def describe(self, complete):
		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import random
import settingsHandler
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __init_db_tables__(self, name):
        if settingsHandler.tableExists("chohan")==False:
            settingsHandler.newTable("chohan", "nick","points")
    def __init__(self):
        self.total=0
        self.userGuesses={}
        self.userScores={}
        self.prize=100
        self.dice=[]
    def action(self, complete):
        msg=complete.message().split()
        nick=complete.user()
        if self.userScores=={}:
            userScores=settingsHandler.readSetting("chohan","nick, points")
            print userScores
            if len(userScores)!=2 and type(userScores[1])!=unicode:
                for user, score, in userScores:
                    self.userScores[user]=int(score)
            else:
                user, score=userScores
                self.userScores[user]=int(score)
        if msg[0].lower()=="guess":
            if self.total==0:
                return ["PRIVMSG $C$ :Nobody's rolled the dice, yet! Roll with roll!"]
            elif nick not in self.userGuesses.keys():
                self.userGuesses[nick]=msg[1]
            else:
                return ["PRIVMSG $C$ :You have already guessed!"]
            msg="Today could be your lucky day! Putting 1/5th of your points into the pot for a total prize of "
            if nick in self.userScores.keys():
                self.prize+=(self.userScores[nick]/5)+100
                self.userScores[nick]-=self.userScores[nick]/5
            msg+=str(self.prize)
        elif msg[0].lower()=="roll":
            if self.total==0:
                self.total=0
                self.dice=[]
                for i in range(2):
                    rtd=random.randint(1,6)
                    self.total+=rtd
                    self.dice.append(rtd)
                    print i,rtd
                self.prize=100
                msg="Dice rolled!"
            else:
                msg="Dice already rolled! Start guessing!"
        elif msg[0].lower()=="reveal":
            if self.total==0:
                return ["PRIVMSG $C$ :No game in progress!"]
            print "revealan"
            oddEven="odd!" if self.total % 2 !=0 else "even!"
            winners=[]
            msg=["PRIVMSG $C$ :The result is "+oddEven+" ("+str(self.dice[0])+"+"+str(self.dice[1])+")"]
            print "winnerappendan"
            for user in self.userGuesses.keys():
                if self.userGuesses[user]==oddEven[:-1]:
                    winners.append(user)
            if winners!=[]:
                prize=self.prize/len(winners)
            else:
                prize=0
            print "winnerpointdistributan",winners
            for winner in winners:
                print winner
                if winner in self.userScores.keys():
                    self.userScores[winner]+=prize
                    settingsHandler.updateSetting("chohan","points",self.userScores[winner],"nick='"+winner+"'")
                else:
                    self.userScores[winner]=prize
                    print "settanwritan"
                    settingsHandler.writeSetting("chohan", ["nick", "points"], [winner,str(prize)])
                    print "settanwrittan"
            print "dbhandlan"
            if len(winners)>1:
                winners=', '.join(winners[:-1])+" and "+winners[-1]
                winString=["winners are "," each"]
            elif len(winners)==1:
                winners=winners[0]
                winString=["winner is ",""]
            else:
                winners=""
                winString=["",""]
            if winners!="":
                msg+=["PRIVMSG $C$ :The "+winString[0]+winners+", and they"+winString[1]+" win "+str(prize)+" points"]
            else:
                msg+=["PRIVMSG $C$ :Nobody wins!"]
            self.total=0
            self.userGuesses={}
            return msg
        elif msg[0].lower()=="points":
            if len(msg)==1:
                return ["PRIVMSG $C$ :You have "+str(self.userScores[nick])+" points"]
            else:
                nick=msg[1]
                if nick in self.userScores.keys():
                    return ["PRIVMSG $C$ :"+nick+" has "+str(self.userScores[nick])+" points"]
                else:
                    return ["PRIVMSG $C$ :"+nick+" has 0 points"]
        elif msg[0].lower()=="e-penis":
            if len(msg)==1:
                return ["PRIVMSG $C$ :8="+('='*(self.userScores[nick]/100))+'D']
            else:
                nick=msg[1]
                if nick in self.userScores.keys():
                    return ["PRIVMSG $C$ :8="+('='*(self.userScores[nick]/100))+'D']
                else:
                    return ["PRIVMSG $C$ :"+nick+" has 0 points"]
        elif msg[0].lower()=="scoreboard":
            num=3 if len(msg)==1 else int(msg[1])
            scoreNames=[]
            for name in self.userScores.keys():
                if self.userScores[name]>0:
                    scoreNames.append((self.userScores[name],name))
            scoreNames.sort(key=lambda scoreName:scoreName[0])
            scoreNames.reverse()
            msg="The top "+str(num)+" users are: "
            for i in range(min(num,len(scoreNames))):
                msg+=scoreNames[i][1]+" with "+str(scoreNames[i][0])+" points"
                if i!=min(num,len(scoreNames))-1:
                    msg+=", "
                else:
                    msg+="!"
        elif msg[0].lower()=="donate":
            name=msg[1]
            amount=int(msg[2])
            if complete.user() not in self.userScores.keys() or name not in self.userScores.keys():
                msg="At least ONE of you don't have any points at all! Play a game of chohan first"
            elif self.userScores[complete.user()]>=amount and amount>0:
                self.userScores[name]+=amount
                self.userScores[complete.user()]-=amount
                settingsHandler.updateSetting("chohan","points",self.userScores[name],"nick='"+name+"'")
                settingsHandler.updateSetting("chohan","points",self.userScores[complete.user()],"nick='"+complete.user()+"'")
                msg="Donated points to "+name+", oh generous one!"
            elif amount<0:
                msg="Nice try!"
            elif self.userScores[complete.user()]<amount:
                msg="You don't have that much to give!"

        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !cho-han module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!cho-han [roll|reveal|points|guess] [odd|even]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from pluginArguments import pluginArguments
from pluginFormatter import formatInput, formatOutput
import globalv
import random
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        commands=msg.split('|')
        random.shuffle(commands)
        command=commands[0]
        plugin=command.split()[0]
        arguments=' '.join(command.split()[1:])
        arguments=":%s PRIVMSG %s :!%s %s"%(complete.userMask(), complete.channel(),plugin ,arguments)
        arguments=formatInput(pluginArguments(arguments))
        pluginOutput=globalv.loadedPlugins[plugin].action(arguments)
        return pluginOutput 
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]

# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
	def gettype(self):
		return "command"
	def action(self, complete):
		return [""]
	def describe(self, complete):
		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import random
import settingsHandler
from pluginFormatter import formatInput
from pluginArguments import pluginArguments
from securityHandler import isAllowed
from userlevelHandler import getLevel
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __init_db_tables__(self, name):
        if settingsHandler.tableExists("'"+name+"'")==False:
            settingsHandler.newTable("'"+name+"'","answer")
    def __init_answers__(self, complete,beRandom):
        self.answers=[x[0] for x in settingsHandler.readSetting("'"+complete.cmd()[0]+"'","answer")]
        if beRandom:
            random.shuffle(self.answers)
    def __level__(self):
        return 0
    def __init__(self):
        self.answers=[]
    def action(self, complete):
        msg=complete.message()
        isElevated=(isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]))
        beRandom=True
        if len(self.answers)==0:
            self.__init_answers__(complete,beRandom)
        if len(msg.split())>=1:
            cmd=msg.split()[0]
            msg=' '.join(msg.split()[1:])
        else:
            cmd=""
            msg=""
        if cmd=="-add" and isElevated:
            settingsHandler.writeSetting("'"+complete.cmd()[0]+"'","answer",msg)
            toReturn="Added that answer"
            self.__init_answers__(complete,beRandom)
        elif cmd=="-delete" and isElevated:
            settingsHandler.deleteSetting("'"+complete.cmd()[0]+"'","answer",msg)
            toReturn="Wiped that answer."
            self.__init_answers__(complete,beRandom)
        elif cmd=="-wipe" and isElevated:
            settingsHandler.dropTable("'"+complete.cmd()[0]+"'")
            settingsHandler.newTable("'"+complete.cmd()[0]+"'","answer")
            toReturn="Answer table wiped!"
            self.__init_answers__(complete,beRandom)
        elif cmd=="-reset" and isElevated:
            self.__init_answers__(complete,beRandom)
            toReturn="Re-randomising list..."
        else:
            toReturn=self.answers.pop()
            inputs=":%s PRIVMSG %s :!%s"%(complete.userMask(), complete.channel(), toReturn)
            input=formatInput(pluginArguments(inputs))
            pluginOut=globalv.loadedPlugins[toReturn.split()[0]].action(input)
            return pluginOut

        return ["PRIVMSG $C$ :"+toReturn]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
from plugins import plugin
import globalv
from random import shuffle
import string
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        lx = [ord(c) for c in string.ascii_lowercase]
        ly = lx[:]
        ux = [ord(c) for c in string.ascii_uppercase]
        uy = ux[:]
        nx = [ord(c) for c in string.digits]
        ny = nx[:]
        px = [ord(c) for c in string.punctuation]
        py = px[:]
        shuffle(lx)
        shuffle(ly)
        shuffle(ux)
        shuffle(uy)
        shuffle(nx)
        shuffle(ny)
        shuffle(px)
        shuffle(py)
        return ["PRIVMSG $C$ :" + unicode(complete.message(), 'utf-8').translate(dict(zip(lx + ux + nx + px, ly + uy + ny + py))).encode('utf-8')]
    def describe(self, complete):
        return ["PRIVMSG $C$ :changes letters to other letters! :D"]
# -*- coding: utf-8 -*-
from plugins import pluginimport globalvimport urllib2currencies={"QUID":"GBP","DOLLAR":"USD","DOLLARS":"USD","POUNDS":"GBP","POUND":"GBP","RUPEE":"INR","RUPEES":"INR"}class pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()		if len(msg.split())==3:			first=msg.split()[1].upper()			second=msg.split()[2].upper()			if first in currencies.keys():				first=currencies[first]			if second in currencies.keys():				second=currencies[second]			if first==second:				return ["PRIVMSG $C$ :Silly $U$ thinks that things can be converted to themselves. Look at silly $U$. Point and laugh."]			toConv=first+second			amount=float(msg.split()[0])		elif len(msg.split())==2:			first=msg.split()[0].upper()			second=msg.split()[1].upper()			toConv=first+second			amount=1		else:			return ["PRIVMSG $C$ :Jesus christ what is wrong with you. Get out."]		convert=float(urllib2.urlopen("http://download.finance.yahoo.com/d/quotes.csv?s="+toConv+"=X&f=sl1d1t1ba&e=.csv").read().split(',')[1])		return ["PRIVMSG $C$ :"+str(amount)+" "+first+" = "+str(round(amount*convert,2))+" "+second]	def describe(self, complete):		return ["PRIVMSG $C$ :I am the !convert module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!convert [number] [from currency] [to currency]"]# -*- coding: utf-8 -*-
from plugins import plugin
from datetime import datetime
import globalv
import pickle
import os
import difflib

def daysTill(date):
    now=datetime.now()
    now = now.replace(hour=10)
    date = date.replace(hour=11)
    
    if date.year == 1900:
        if date.month > now.month:
            date=date.replace(year=now.year)
        elif date.month < now.month:
            date=date.replace(year=now.year+1)
        else:
            if date.day > now.day:
                date=date.replace(year=now.year)
            elif date.day < now.day:
                date=date.replace(year=now.year+1)
            else:
                return 0
    return (date-now).days

def parseDate(date):
    aa = monthName(date.month)+" "+str(date.day)
    if date.day%10==1 and date.day!=11:
        aa+="st"
    elif date.day%10==2 and date.day!=12:
        aa+="nd"
    elif date.day%10==3 and date.day!=13:
        aa+="rd"
    else:
        aa+="th"
    if date.year!=1900:
        aa+=" "+str(date.year)
    return aa

def monthName(month):
    return ["","January","February","March","April","May","June","July","August","September","October","November","December",][month]

def getDateFromString(eventdate,formats):
    eventdate=eventdate.replace("gust","____")
    eventdate=eventdate.replace("st","").replace("nd","").replace("rd","").replace("th","").replace("____","gust")
            
    validDate=False
    for dformat in formats:
        try:
            newdate = datetime.strptime(eventdate, dformat)
            validDate=True
            break
        except:
            validDate=False
    if not validDate:
        return False
    return newdate

def compareEvent(e1, e2):
    return daysTill(e1[1])-daysTill(e2[1])

class pluginClass(plugin):
    def __init__(self):
        self.events = []
        self.formats = [
            "%Y-%m-%d",    #2017-03-31
            "%B %d, %Y",   #March 31, 2017
            "%B %d %Y",    #March 31 2017
            "%d %B %Y",    #31 March 2017
            "%d %B",       #31 March
            "%B %d"       #March 31
            ]
    def gettype(self):
        return "command"
    
    def till(self,date):
        eventname=date
        
        eventExists = False
        for x in self.events:
            if x[0]==eventname:
                dd = daysTill(x[1])
                eventExists = True
                break

        if not eventExists:
            newdate=getDateFromString(eventname,self.formats)
            if newdate:
                eventExists = True
                dd=daysTill(newdate)

        if not eventExists:
            response = ["PRIVMSG $C$ :"+eventname+" has not been set as an event yet."]
            close_matches = difflib.get_close_matches(eventname, [x[0] for x in self.events])
            if len(close_matches) > 0:
                response.append("PRIVMSG $C$ :Did you mean: " + ', '.join(close_matches))
            return response
            
        if dd==0:
            return ["PRIVMSG $C$ :Today it's "+eventname+"!"]
        elif dd<0:
            return ["PRIVMSG $C$ :"+eventname+" happened "+str(-dd)+" days ago."]
        else:
            return ["PRIVMSG $C$ :"+str(dd)+" days till "+eventname]
        
    def action(self, complete):
        fileName="events-%s"%complete.cmd()[0]
        filePath=os.path.join("config",fileName)
        if os.path.exists(filePath):
            with open(filePath) as eventFile:
                self.events=pickle.load(eventFile)
        s=complete.message().split()
        if len(s)<1:
            return ["PRIVMSG $C$ :Invalid parameters"]
        if s[0]=="upcoming":
            upcoming = sorted([x for x in self.events if daysTill(x[1])>0],compareEvent)
            aa = "Upcoming: "
            for event in upcoming[:5]:
                aa += event[0] + " at " + parseDate(event[1]) + "; "
                
            return ["PRIVMSG $C$ :"+aa]
        if s[0]=="till":
            return self.till(' '.join(s[1:]))
        if s[0]=="set" or s[0]=="override":
            if not "as" in s:
                return ["PRIVMSG $C$ :Invalid usage; use: !countdown " + s[0] + " [Event name] as [Date]"]
            asPos=s.index("as")
            eventname=' '.join(s[1:asPos])
            ddate=' '.join(s[asPos+1:])

            eventFound = False
            
            for x in self.events:
                if x[0]==eventname:
                    if s[0]=="set":
                        return ["PRIVMSG $C$ :That event has already been set at " + parseDate(x[1]) + ". Use <!countdown override " + eventname + " as " + ddate + "> to override"]
                    else:
                        eventFound = True

            if not eventFound and s[0]=="override":
                response = ["PRIVMSG $C$ :"+eventname+" has not been set as an event yet."]
                close_matches = difflib.get_close_matches(eventname, [x[0] for x in self.events])
                if len(close_matches) > 0:
                    response.append("PRIVMSG $C$ :Did you mean: " + ', '.join(close_matches))
                return response

            newdate=getDateFromString(ddate,self.formats)
                    
            if newdate:
                if s[0]=="set":
                    self.events.append([eventname,newdate])
                else:
                    for x in range(len(self.events)):
                        if self.events[x][0]==eventname:
                            self.events[x][1]=newdate
                            
                with open(filePath,"w") as eventFile:
                    pickle.dump(self.events,eventFile)
                return ["PRIVMSG $C$ :"+eventname+" successfully added!"]
            else:
                return ["PRIVMSG $C$ :Invalid date format."]
        else:
            return self.till(' '.join(s[0:]))

        return ["PRIVMSG $C$ :Invalid Parameters"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !countdown module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!countdown set [Event name] as [Date]","PRIVMSG $C$ :!countdown (till) [Event name]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import settingsHandler
import globalv
import random
class crab(object):
    def __init__(self,user, name, XP, level, abilities,abilityList):
        print "This is even running"
        base=5
        self.user=user
        self.name=name
        self.XP=XP
        self.level=level
        self.abilities=abilities
        self.abilityList=abilityList
        self.attack=base+(base*0.02*self.level)
        self.defence=base+(base*0.015*self.level)
        self.agility=base+(base*0.01*self.level)
        self.enemyAttack=100 #% that gets to you, applied before defence
        self.enemyAgility=100
        self.XPModifier=100#% of XP you get
        self.hp=2*base+(base*level*0.05)
        self.maxhp=self.hp
        self.critMultiplier=1
        self.HPRegen=0
        self.numAbilities=0
        self.savevsdeath=0#chance to save vs death
        self.ondefend=[]
        self.onattack=[]
        self.ondeath=[]
        self.onsave=[]
        for ability in range(len(self.abilities)):
            if self.abilities[ability]=="1":
                self.numAbilities+=1
                self.addAbility(ability)
        if self.level>100:
            self.level=100
    def addAbility(self, ability):
        print "Adding ability",ability
        effects=self.abilityList[ability][2]
        effects=effects.split('|')
        for effect in effects:
            stat=effect.split()[1]
            amount=int(effect.split()[0])
            if stat=="attack":
                self.attack*=1+amount/100.0
            elif stat=="defence":
                self.defence*=1+amount/100.0
            elif stat=="agility":
                self.agility*=1+amount/100.0
            elif stat=="hp":
                self.hp*=1+amount/100.0
                self.maxhp=self.hp
            elif stat=="xp":
                self.XPModifier+=amount
            elif stat=="regen":
                self.HPRegen+=amount
            elif stat=="save":
                self.savevsdeath+=amount
            elif stat=="enemyattack":
                self.enemyAttack+=amount
            elif stat=="crit":
                self.critMultiplier*=1+amount/100.0
            elif stat=="enemyagility":
                self.enemyAgility+=amount
            elif stat=="deathchance":
                self.ondeath.append(ability)
            elif stat=="savechance":
                self.onsave.append(ability)
            elif stat=="chance":
                self.onattack.append(ability)
            elif stat=="defencechance":
                self.ondefend.append(ability)
    def getAttackString(self, crab):
        attacks=[]
        attacks.append("strikes")
        attacks.append("slices")
        attacks.append("cuts")
        attacks.append("stabs")
        if self.abilities[2]=="1":
            attacks.append("slices through %s"%crab.name)
        if self.abilities[3]=="1":
            attacks.append("smashes")
        if self.abilities[5]=="1":
            attacks.append("makes an FTL jump off of %s"%crab.name)
        if self.abilities[6]=="1":
            attacks.append("precisely strikes")
        if self.abilities[8]=="1":
            attacks.append("triple-cuts")
        if self.abilities[9]=="1":
            attacks.append("telekinetically throws %s into the ground"%crab.name)
        if self.abilities[11]=="1":
            attacks.append("uses the vulcan death claw")
        if self.abilities[12]=="1":
            attacks.append("jump kicks")
            attacks.append("flying kicks")
            attacks.append("spinning kicks")
        if self.abilities[13]=="1":
            attacks.append("blasts")
            attacks.append("counterattacks with defence lasers")
        if self.abilities[18]=="1":
            attacks.append("smites")
        if self.abilities[20]=="1":
            attacks.append("blasts %s with lasers"%crab.name)
            attacks.append("carves through %s with a high powered laser"%crab.name)
        if self.abilities[22]=="1":
            attacks.append("throws")
            attacks.append("smashes")
            attacks.append("kicks")
        if self.abilities[27]=="1":
            attacks.append("cuts")
            attacks.append("harnesses the power of an ancient god")
            attacks.append("calls upon eternity")
        if self.abilities[31]=="1":
            attacks.append("shoots a missile at %s because that is his weakness"%crab.name)
            attacks.append("launches a missile")
        if self.abilities[32]=="1":
            attacks.append("makes a damn good hit")
        if self.abilities[33]=="1":
            attacks.append("emits an aura of badassery")
        random.shuffle(attacks)
        return attacks[0]
    def attackCrab(self,crab):
        criticalString=""
        enemyDefence=crab.defence
        enemyAgility=crab.agility*(self.enemyAgility/100.0)
        attack=self.attack*(crab.enemyAttack/100.0)
        agility=self.agility*(crab.enemyAgility/100.0)
        miss=random.randint(1,int(enemyAgility*1.5))>agility
        if miss:
            return "%s %s, but misses!"%(self.name,self.getAttackString(crab))
        print self.onattack
        for ability in self.onattack:
            print "Checking onattack ability",ability
            if ability==21 and random.randint(0,100)<5:
                attack+=2
                attack*=3
                criticalString+="%s calls in an orbital strike! "%self.name
            elif ability==29 and random.randint(0,100)<5:
                attack*=5
                criticalString="%s uses hyper beam! "%self.name
            elif ability==19 and random.randint(0,int(self.maxhp))>self.hp:
                attack*=1.5
                self.HPRegen+=1
                criticalString+="%s activates their devil trigger! "%self.name
        damage=random.randint(1,int(attack*100))
        damage/=100
        critical=random.randint(-100,100)*self.critMultiplier
        if critical>=90:
            damage+=2
            damage*=2
            criticalString+="Critical Hit! "
        elif critical<=-90:
            damage/=4
            criticalString+="Critical Failure! "
        damage*=1-(enemyDefence/50.0)
        damage=int(damage)
        crab.hp-=damage
        self.hp+=self.HPRegen
        return "%s%s %s for %s damage!"%(criticalString, self.name, self.getAttackString(crab), damage)
    def isDead(self, crab):
        if self.hp>0:
            return (False,"")
        elif random.randint(0,100)<self.savevsdeath:
            for ability in self.onsave:
                if ability==23:
                    if random.randint(0,100)<=10:
                        crab.hp=0
                        return (False, "%s, in a last chance strike, kills %s in one clean hit!"%(self.name,crab.name))
            return (False, "%s should be dead, but just keeps on going!")
        else:
            return (True, "")
    def awardXP(self, XP):
        self.XP+=XP*(self.XPModifier/100.0)
        levelledup=0
        while self.XP>((self.level+1)*self.level*100) and self.level<100:
            self.level+=1
            levelledup=1
        if levelledup:
            return self.level
        else:
            return False
    def awardAbility(self, ability):
        self.abilities=self.abilities[:ability]+"1"+self.abilities[ability+1:]
    def removeAbility(self, ability):
        self.abilities=self.abilities[:ability]+"0"+self.abilities[ability+1:]
    def save(self,table):
        settingsHandler.executeQuery("UPDATE %s SET name='%s', XP=%s, level=%s, abilities='%s' WHERE user='%s'"%(table, self.name, self.XP, self.level, self.abilities,self.user))



class pluginClass(plugin):
    def addAbility(self, name, effects):
        self.abilities.append((len(self.abilities), name, effects))
    def gettype(self):
        return "command"
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name, "user","name","XP","level", "Abilities")
    def __init__(self):
        self.abilities=[]
        self.addAbility("Adamantium Shell","25 defence")
        self.addAbility("Accelerated Reflexes","5 agility")
        self.addAbility("Monomolecular Claw","15 attack")
        self.addAbility("Rocket Claw","5 attack|5 agilty")
        self.addAbility("Energy Shielding","25 defence")
        self.addAbility("Jump Drive","5 agility")
        self.addAbility("Assisted Aim","-10 enemyattack")
        self.addAbility("Cybernetic Enhancements","5 attack|5 defence|5 agility|5 hp")
        self.addAbility("Tri-Blade Claw","15 attack")
        self.addAbility("Telekenetic Flight","15 agility")
        self.addAbility("Slow-Motion Replay","10 xp")
        self.addAbility("Vulcan Death Claw","15 attack")
        self.addAbility("Kung-Fu", "5 attack|10 defence")
        self.addAbility("Secondary Lasers", "25 defence")
        self.addAbility("Temporal Replay","-20 enemyagility")
        self.addAbility("Omniprescence","-20 enemyagility")
        self.addAbility("Healing Touch","10 hp|1 regen")
        self.addAbility("Faith","5 save")
        self.addAbility("Smite","1 chance")
        self.addAbility("Devil Trigger","1 chance")
        self.addAbility("Primary Lasers","15 attack")
        self.addAbility("Orbital Strike","1 chance")
        self.addAbility("Micro Mecha", "15 attack | 10 defence")
        self.addAbility("Last Stand", "1 savechance")
        self.addAbility("Intense Training", "15 attack | 10 defence")
        self.addAbility("Punch Out Cthulhu", "5 save")
        self.addAbility("Nuclear Powered", "1 deathchance")
        self.addAbility("Infinity +1 Sword", "15 attack")
        self.addAbility("Cat-Like Reflexes", "15 agility")
        self.addAbility("Hyper Beam", "1 chance")
        self.addAbility("Lucky Shot", "25 crit")
        self.addAbility("Missile Launcher", "10 attack|10 crit")
        self.addAbility("Improbable Aim", "25 crit")
        self.addAbility("Badass Longcoat", "25 defence")

    def getCrabFromDatabase(self, table, user):
        try:
            data=settingsHandler.executeQuery("SELECT name, XP, level, abilities FROM %s WHERE user='%s'"%(table,user))
            data=data[0]
            newCrab=crab(user, data[0][:50], data[1], data[2], data[3].rjust(len(self.abilities),"0"), self.abilities)
            return newCrab
        except Exception as detail:
            print detail
            return False

    def action(self, complete):
        msg=complete.message()
        global crab
        if msg.split()[0]=="battle" or msg.split()[0]=="blowbyblow":
            events=[]
            if len(msg.split())==1:
                oneCrab=self.getCrabFromDatabase(complete.cmd()[0],complete.user())
                newLevel=oneCrab.level+int(random.gauss(0,4))
                if newLevel<=0:
                    newLevel=1
                if newLevel>100:
                    newLevel=100
                nameList=["Giant Enemy Crab", "Enemy Crab", "The Lord Of The Moon Seas", "God", "Hyper Crab", "Devil Crab", "Generic Enemy Crab", "Generic Angsty Teenage Crab","Hitler"]
                random.shuffle(nameList)
                newName=nameList[0]
                abilityString="1"*(1+int(newLevel/5))
                abilityString=abilityString.rjust(len(self.abilities), "0")
                abilityString=list(abilityString)
                random.shuffle(abilityString)
                abilityString=''.join(abilityString)
                twoCrab=crab("-WorldSpace-", newName, oneCrab.XP, newLevel, abilityString, self.abilities)
                events.append("PRIVMSG $C$ :%s has come across the level %s %s!"%(oneCrab.name, twoCrab.level, twoCrab.name))
            else:
                oneCrab=self.getCrabFromDatabase(complete.cmd()[0],complete.user())
                twoCrab=self.getCrabFromDatabase(complete.cmd()[0],msg.split()[1])
            if oneCrab==False:
                return ["PRIVMSG $C$ :You don't have a crab! Run !crab init [crab name] to get one!"]
            elif twoCrab==False:
                print "it's this"
                return ["PRIVMSG $C$ :%s doesn't have a crab! They can run !crab init [crab name] to get one!"%msg.split()[1]]
            turn=0
            battleWon=False
            if oneCrab.level < twoCrab.level-5:
                events.append("PRIVMSG $C$ :%s gets an underdog bonus! Attack and Defence improved 20%%!"%oneCrab.name)
                oneCrab.attack*=1.2
                oneCrab.defence*=1.2
            if twoCrab.level < oneCrab.level-5:
                events.append("PRIVMSG $C$ :%s gets a jerk penalty! Attack and Defence drop 25%%!"%oneCrab.name)
                oneCrab.attack*=0.75
                oneCrab.defence*=0.75
            for i in range(30):
                if turn==0:
                    events.append("PRIVMSG $C$ :"+oneCrab.attackCrab(twoCrab))
                else:
                    events[-1]+="; "+twoCrab.attackCrab(oneCrab)
                oneIsDead=oneCrab.isDead(twoCrab)
                twoIsDead=twoCrab.isDead(oneCrab)
                if oneIsDead[0]:
                    winner=twoCrab
                    loser=oneCrab
                    battleWon=True
                    if oneIsDead[1]!="":
                        events.append("PRIVMSG $C$ :%s"%oneIsDead[1])
                elif twoIsDead[0]:
                    winner=oneCrab
                    loser=twoCrab
                    battleWon=True
                    if twoIsDead[1]!="":
                        events.append("PRIVMSG $C$ :%s"%twoIsDead[1])
                if battleWon:
                    break
                else:
                    turn=(1 if turn==0 else 0)
            if msg.split()[0]=="battle":
                events=[]
            if battleWon:
                winnerXP=((loser.level+1)*(loser.level)*10)/((winner.level/5)+1)
                if loser.user!=winner.user:
                    if winner.user!="-WorldSpace-":
                        levelUp=winner.awardXP(winnerXP)
                    else:
                        levelUp=False
                    events.append("PRIVMSG $C$ :%s won the battle, and is awarded %s XP!"%(winner.name, winnerXP))
                else:
                    levelUp=False
                    events.append("PRIVMSG $C$ :%s won the battle, but gets no XP from fighting themself!"%(winner.name,))
                if levelUp!=False:
                    events.append("PRIVMSG $C$ :%s levelled up! %s is now level %s!"%(winner.name, winner.name, levelUp))
                if int(levelUp/5)>winner.numAbilities-1:
                    events.append("PRIVMSG $C$ :%s can now choose %s more abilities!"%(winner.name,1+int(levelUp/5)-winner.numAbilities))
                if winner.user!="-WorldSpace-":
                    winner.save(complete.cmd()[0])
            else:
                events.append("PRIVMSG $C$ :Both crabs retreat to recover. There is no winner!")
            return events
        elif msg.split()[0]=="init":
            if len(msg.split())==1:
                return ["PRIVMSG $C$ :You need to give your new crab a name!"]
            name=' '.join(msg.split()[1:])
            settingsHandler.executeQuery("INSERT INTO %s VALUES ('%s','%s',0,1,'%s')"%(complete.cmd()[0],complete.user(), name, "0"*len(self.abilities)))
            return ["PRIVMSG $C$ :%s successfully initialised! Type !crab list abilities to see all abilities, and !crab choose ability [name] to choose one!"%name]
        elif msg.split()[0]=="rename":
            newCrab=self.getCrabFromDatabase(complete.cmd()[0], complete.user())
            newCrab.name=' '.join(msg.split()[1:])
            newCrab.save(complete.cmd()[0])
        elif msg.split()[0]=="stats" or msg.split()[0]=="info":
            returnString=[]
            if len(msg.split())==1:
                user=complete.user()
            else:
                user=msg.split()[1]
            newCrab=self.getCrabFromDatabase(complete.cmd()[0], user)
            if newCrab==False:
                return ["PRIVMSG $C$ :%s doesn't have a crab! Run !crab init [crab name] to get one"%user]
            returnString.append("PRIVMSG $C$ :%s's stats: %s HP, %s XP, Level %s, %s attack, %s defence, %s agility, %s%% crit rate. %s has %s free ability slot(s)."%(newCrab.name, newCrab.hp, newCrab.XP, newCrab.level, newCrab.attack, newCrab.defence, newCrab.agility,newCrab.critMultiplier*10,newCrab.name,1+int(newCrab.level/5)-newCrab.numAbilities))
            ret=[]
            for ability in range(len(newCrab.abilities)):
                if newCrab.abilities[ability]=="1":
                    for abilitylist in self.abilities:
                        if abilitylist[0]==ability:
                            ret.append(abilitylist[1])
            returnString.append("PRIVMSG $C$ :Abilities are: "+', '.join(ret))
            return returnString
        elif msg.split()[0]=="list":
            if msg.split()[1]=="abilities":
                returnString=", ".join([ability[1] for ability in self.abilities])
                return ["PRIVMSG $C$ :"+returnString]
        elif msg.split()[0:2]==["choose","ability"]:
            targetAbility=' '.join(msg.split()[2:])
            newCrab=self.getCrabFromDatabase(complete.cmd()[0], complete.user())
            if int(newCrab.level/5)<=newCrab.numAbilities-1:
                return ["PRIVMSG $C$ :%s has no free ability slots!"%newCrab.name]
            ID=-1
            for ability in self.abilities:
                if ability[1].lower()==targetAbility.lower():
                    abilityName=ability[1]
                    ID=ability[0]
            if ID!=-1:
                newCrab.awardAbility(ID)
                newCrab.save(complete.cmd()[0])
                return ["PRIVMSG $C$ :Awarded %s the ability '%s'"%(newCrab.name, abilityName)]
            else:
                return ["PRIVMSG $C$ :There is no ability by that name!"]
        elif msg.split()[0:2]==["remove","ability"]:
            targetAbility=' '.join(msg.split()[2:])
            newCrab=self.getCrabFromDatabase(complete.cmd()[0], complete.user())
            for ability in self.abilities:
                if ability[1].lower()==targetAbility.lower():
                    abilityName=ability[1]
                    ID=ability[0]
            if newCrab.abilities[ID]=="0":
                return ["PRIVMSG $C$ :%s does not have that ability!"%newCrab.name]
            else:
                newCrab.removeAbility(ID)
                newCrab.save(complete.cmd()[0])
                return ["PRIVMSG $C$ :Removed that ability"]
        elif msg.split()[0]=="resetAbilities":
            newCrab=self.getCrabFromDatabase(complete.cmd()[0], complete.user())
            newCrab.abilities="0"*len(self.abilities)
            newCrab.save(complete.cmd()[0])
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
import urllib, urllib2

class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        query = {'q':'define: %s' % complete.message()}
        url = 'http://www.google.com/search?sclient=psy&hl=en&site=&source=hp&%s&btnG=Search' % (urllib.urlencode(query))
        headers = {
            'Host': 'www.google.com',
            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1'
        }
        req = urllib2.Request(url, headers = headers)
        first = urllib2.urlopen(req)
        source = first.read()

        url = re.search('/search[^\'"]+tbs=dfn:1[^\'"]+', source)
        if url:
            url = 'http://www.gooogle.com' + url.group(0).replace('&amp;','&')
        else:
            return ["PRIVMSG $C$ :No Definitions."]

        req = urllib2.Request(url, headers = headers)
        first = urllib2.urlopen(req)
        source = first.read()

        info = re.search('<li style="list-style:none">(?P<definition>.+?)</li>.+?url=(?P<source>.+?)&', source)
        if info == None:
            return ["PRIVMSG $C$ :No Definitions."]
        
        definition = info.group('definition')
        source = info.group('source')
        source = urllib.unquote(source)
        
        return ["PRIVMSG $C$ :%s" % definition, "PRIVMSG $C$ :from %s" % source]
    def describe(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ :I am the !define module. I use google to define words!","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!define [word]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
import urllib
import urllib2
import xml.sax.saxutils
import mimetypes
def fixXMLEntities(match):
    value=int(match.group()[2:-1])
    return chr(value)
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        logindata={'email':"AHPhoshi@gmail.com", "password":"11235813",}
        tumblrids=[]
        for message in complete.message().split():
            tumblrids.append(message.split('/')[-1])
        for tumblrid in tumblrids:
            logindata.update({"post-id":tumblrid})
            uploadData=urllib.urlencode(logindata)
            req=urllib2.Request("http://www.tumblr.com/api/delete",uploadData)
            con=urllib2.urlopen(req)
        return ["PRIVMSG $C$ :Erased that post."]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the plugin that follows URLs","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :None - I monitor all input, if you have a url in your text, I will find it."]
# -*- coding: utf-8 -*-
from plugins import pluginimport globalvimport urllib2, redict={}page=urllib2.urlopen("http://draconic.twilightrealm.com/vocabulary.php").read()page=page.split("<table")[1]page=page.split("</table>")[0]page=page.split("<tr>")[2:]for word in page:	word=word.split("<td>")	dict.update({word[2][:-16].replace(' ','-'):word[1][:-16].replace(' ','-')})class pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()		page=""		translated=""		punctuation=re.split("[a-zA-Z']",msg)		marks=[]		for mark in punctuation:			if mark!="":				marks.append(mark)		i=0		for word in msg.split():			word=re.sub("[^a-zA-Z']","",word)			if word.lower() in dict:				toAdd=dict[word.lower()]				if word[0].isupper():					toAdd=toAdd.capitalize()				translated+=toAdd				if i<len(marks):					translated+=marks[i]				else:					translated+=" "			else:				translated+=word				if i<len(marks):					translated+=marks[i]				else:					translated+=" "			i+=1		if complete.user()!="Silver_Skree":			return ["PRIVMSG $C$ :"+translated]	def describe(self, complete):		msg=complete.message()		return ["PRIVMSG $C$ :I am the !draconic2english module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!draconic2english [input]"]# -*- coding: utf-8 -*-
from plugins import plugin
import globalv, urllib2,urllib
import time
import os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        arguments=complete.message().split()
        channel=complete.channel()
        msg=0 
        for argument in arguments:
            if argument.isdigit()==True:
                msg=argument
            if argument[0]=='#':
                channel=argument
        now=time.gmtime()
        year=now[0]
        day=now[7]-int(msg)
        if day<0:
            year-=1
            day+=365
        file="/"+os.path.join("home","py","omg","logs","LogFile - "+channel+"-"+str(year)+"-"+str(day))
        print "Linking",file
        print os.path.exists(file)
        newFile="/home/py/Dropbox/Public/"+file+".txt"
        print newFile
        print os.getcwd()
        if os.path.exists(newFile)==False:
            #os.symlink(file,newFile)
            os.system('ln -s "%s" "%s"' % (file, newFile))
        msg="http://dl.dropbox.com/u/10241580/"+file.replace(' ','%20').replace('#','%23')+".txt"
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !pastebinLogs module. I return a pastebin URL with the logs of today - [msg].","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!pastebinLogs [offset]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from userlevelHandler import getLevel
from securityHandler import isAllowed
import settingsHandler
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 150
    def action(self, complete):
        msg=complete.message()
        if msg.split()[0]=="-list":
           users=settingsHandler.readSetting("autoidentifyd","nickname, level")
           out=[]
           for name,level in users:
               if len(msg.split())==1:
                   out.append(name+":"+str(level))
               elif msg.split()[1].lower()==name.lower():
                   out.append(name+":"+str(level))
           msg=', '.join(out)
        elif len(msg.split())==1:
           users=settingsHandler.readSetting("autoidentifyd","nickname, level")
           for name,level in users:
               if name==msg:
                   return ["PRIVMSG $C$ :%s"%(level)]
           return ["PRIVMSG $C$ :0"]


        elif isAllowed(complete.userMask())>getLevel(complete.cmd()[0]):
            if msg.split()[0] in [x[0] for x in settingsHandler.readSetting("autoidentifyd","nickname")]:
                settingsHandler.updateSetting("autoidentifyd","level",str(msg.split()[1]), where="nickname='%s'"%msg.split()[0])
                msg="Level updated"
                globalv.miscVars[2].append((msg.split()[0], msg.split()[1]))
            else:
                settingsHandler.writeSetting("autoidentifyd",["nickname","level"], [msg.split()[0], msg.split()[1]])
                msg="User Elevated"
                globalv.miscVars[2].append((msg.split()[0], msg.split()[1]))
        else:
            msg="Only elevated users can do this!"
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import pluginimport globalvimport urllib2, redict={}page=urllib2.urlopen("http://draconic.twilightrealm.com/vocabulary.php").read()page=page.split("<table")[1]page=page.split("</table>")[0]page=page.split("<tr>")[2:]for word in page:	word=word.split("<td>")	dict.update({word[1][:-16].replace(' ','-'):word[2][:-16].replace(' ','-')})class pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		print complete		msg=complete.message()		page=""		translated=""		punctuation=re.split("[a-zA-Z']",msg)		marks=[]		for mark in punctuation:			if mark!="":				marks.append(mark)		i=0		for word in msg.split():			word=re.sub("[^a-zA-Z']","",word)			if word.lower() in dict:				toAdd=dict[word.lower()]				if word[0].isupper():					toAdd=toAdd.capitalize()				translated+=toAdd				if i<len(marks):					translated+=marks[i]				else:					translated+=" "			else:				translated+=word				if i<len(marks):					translated+=marks[i]				else:					translated+=" "			i+=1		if complete.user()!="Silver_Skree":			return ["PRIVMSG $C$ :"+translated]	def describe(self, complete):		msg=complete.message()		sender=complete[0].split(' ')		sender=sender[2]		return ["PRIVMSG $C$ :I am the !english2draconic module. I translate an english sentace into a draconic one.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!english2draconic [input]"]# -*- coding: utf-8 -*-
from plugins import pluginimport globalvdef fib(num):	first = 0	second = 1	for i in range(num):		second = first + second		first = second - first	return firstclass pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()		fibs=[]		for i in range(0,int(msg)):			fibs.append(str(fib(i)))		print fibs		return ["PRIVMSG $C$ :"+', '.join(fibs)]	def describe(self, complete):		msg=complete.message()		sender=complete[0].split(' ')		sender=sender[2]		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
	def gettype(self):
		return "command"
	def action(self, complete):
		msg=complete.message()
		globalv.timeUsers[msg.split()[0]]=complete.channel()
		print globalv.timeUsers
		return ["PRIVMSG "+msg.split()[0]+" :FINGER"]
	def describe(self, complete):
		return ["PRIVMSG $C$ :I am the !time module. I return a user's local time.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!time [user]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import shlex
import re
from pluginArguments import pluginArguments
from pluginFormatter import formatInput, formatOutput

class pluginClass(plugin):
    def gettype(self):
        return "command"
    def expand(self, toExpand, toExpandWith):
        expansions = re.findall("\$([0-9]*)\$", toExpand)
        if len(expansions) == 0 and toExpand.find('$*$')==-1:
            return "%s %s"%(toExpandWith, toExpand)
        for expansion in expansions:
            index = int(expansion)-1
            if len(toExpandWith.split())>index:
                toExpand = toExpand.replace("$%s$"%expansion, toExpandWith.split()[index])
        toExpand = toExpand.replace('$*$', toExpandWith)
        return toExpand


    def action(self, complete):
        commands = shlex.split(complete.message())
        commands = [c.replace("\x00","") for c in commands] #Working around a unicode bug in shlex
        commandString = commands[0]
        commands = commands[1:15]
        commandString = commandString.split(' ',1)
        outputList=[]
        for command in commands:
            if len(commandString)>1:
                argumentsToRun = self.expand(commandString[1], command)
            else:
                argumentsToRun = command 
            commandToRun = commandString[0]
            print "Running command", commandToRun, "with arguments", argumentsToRun
            print "Constructing plugin object"
            arguments = pluginArguments(complete.complete())
            firstBit=arguments.complete().split(':')[1]
            arguments.setComplete(":"+firstBit+":"+globalv.commandCharacter+commandToRun+" "+argumentsToRun)
            print "Pre-formatting plugin object:", arguments.complete()
            arguments=formatInput(arguments)
            print "Running command"
            pluginOutput=globalv.loadedPlugins[commandToRun].action(arguments)
            print "Formatting output"
            output = formatOutput(pluginOutput, complete)
            print "Decoding output"
            output = [o.decode('utf-8') for o in output]
            print "Success! Adding output to output list",output
            outputList+=output
        return outputList
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __append_seperator__(self):
        return True
    def action(self, complete):
        print "X"
        msg=complete.message()
        formatRules=msg.split('::')[0]
        output=formatRules
        toFormat=msg.split('::')[1]
        highest=[int(x) for x in re.findall("\$([0-9]+)",formatRules)]
        if highest!=[]:
            highest.sort()
            highest=highest[-1]
            for x in xrange(highest+1):
                try:
                    output=output.replace("$%s"%x,toFormat.split()[x])
                except:
                    print "formatter: Index failure"
        output=output.replace("$*",toFormat)
        return ["PRIVMSG $C$ :"+output]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        def makeFuzzyTime(hour, minute):
            minuteMessages=[(range(0,5),"%s o'clock"), (range(5,10),"five past %s"), (range(10,15), "ten past %s"), \
            (range(15,20),"quarter past %s"), (range(20,25), "twenty past %s"), (range(25,30), "twenty five past %s"), (range(30,35), "half past %s"), \
            (range(35,40), "twenty five to %s"), (range(40,45), "twenty to %s"), (range(45, 50), "quarter to %s"), (range(50,55), "ten to %s"), \
            (range(55,60), "five to %s")]
            hourNames=["midnight", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", \
            "eleven", "noon", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven"]
            minuteMessages=map(lambda tup: list(tup), minuteMessages)
            for message in minuteMessages:
                message[0]=tuple(map(lambda x: x-2, list(message[0])))
                message[0]=tuple(map(lambda x: x+60 if x<0 else x, list(message[0])))
                if minute in message[0]:
                    if minute > 33: #35 minutes to end "half past", plus the two minute wiggle room
                        hour+=1
                        if hour>23:
                            hour=0
                    if message[1]=="%s o'clock" and hour in [0, 12] and minute in minuteMessages[0][0]:
                        return hourNames[hour]
                    return (message[1]%hourNames[hour]) + (" AM" if 0 < hour < 12 else "" if 12 < hour else "")
        hour=int(complete.message().split(':')[0])
        minute=int(complete.message().split(':')[1])
        return ["PRIVMSG $C$ :"+makeFuzzyTime(hour, minute)]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
	def gettype(self):
		return "command"
	def action(self, complete):
		return ["PRIVMSG $C$ :"+str(globalv.input.getNumActiveSources())]
	def describe(self, complete):
		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
from securityHandler import isAllowed
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        hostmask = globalv.miscVars[0][complete.message()]
        return ["PRIVMSG $C$ :"+str(isAllowed(hostmask))]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
import htmllib
import urllib2,urllib
import settingsHandler

def unescape(s):
    p = htmllib.HTMLParser(None)
    p.save_bgn()
    p.feed(s)
    return p.save_end()

class pluginClass(plugin):
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name, "showTitle")
        settingsHandler.writeSetting(name,"showTitle","True")
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        terms=[x.strip() for x in msg.split(',')]
        topResult=(0,'')
        resultScores={}
        for word in terms:
            url = 'http://ajax.googleapis.com/ajax/services/search/web?v=1.0&q='+word.replace(' ', '%20')
            response = urllib2.urlopen(url)
            page = response.read()
            result = re.findall("estimatedResultCount.*?([0-9]+)\"", page)[0]
            result=int(result)
            resultScores[word]=result
            if result>topResult[0]:
                topResult=(result, word)
            otherTerms=[]
            for word in resultScores.keys():
                if word!=topResult[1]:
                    otherTerms.append(word+" with "+str(resultScores[word]))
        return ["PRIVMSG $C$ :Winner is "+topResult[1]+" with "+str(topResult[0])+" results!","PRIVMSG $C$ :Other results were: "+', '.join(otherTerms)]
    def describe(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ :I am the !googleFights module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!googleFights [list of words to compare]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
import htmllib
import urllib2,urllib
import settingsHandler

def unescape(s):
    p = htmllib.HTMLParser(None)
    p.save_bgn()
    p.feed(s)
    return p.save_end()

class pluginClass(plugin):
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name, "showTitle")
        settingsHandler.writeSetting(name,"showTitle","True")
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        url = 'http://ajax.googleapis.com/ajax/services/search/web?v=1.0&q='+msg.replace(' ', '%20')
        try:
            response = urllib2.urlopen(url)
            page = response.read()
            result = re.search("(?P<url>\"url\":\"[^\"]+)", page).group('url').decode('utf-8')
            result=result[7:]
            title = re.search("(?P<url>\"titleNoFormatting\":\"[^\"]+)", page).group('url').decode('utf-8')
            title=title[21:]
            titleString=unescape(title)+" (at "+urllib.unquote(result)+')' if settingsHandler.readSetting(complete.cmd()[0],"showTitle")=="True" else urllib.unquote(result)
        except:
            titleString="No results!"
        return ["PRIVMSG $C$ :"+titleString]
    def describe(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ :I am the !google module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!google [phrase]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        if msg in globalv.nicks.keys():
            return ["PRIVMSG $C$ :"+globalv.nicks[msg]]
        return ["PRIVMSG $C$ :Unknown User"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import pluginfrom settingsHandler import readSettingimport globalvclass pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		return ["PRIVMSG NickServ :IDENTIFY "+readSetting("core","password")]	def describe(self, complete):		return ["PRIVMSG $C$ :I am the !opYourself module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!opYourself"]# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import random
import settingsHandler
import shlex
import braceParser
from pluginFormatter import formatInput
from pluginArguments import pluginArguments
from userlevelHandler import getLevel
from securityHandler import isAllowed
import re
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __init__(self):
        self.Voted={}
    def action(self, complete):
        reload(braceParser)
        parseBraces=braceParser.parseBraces
        try:
            msg=parseBraces(complete.fullMessage())
        except Exception as detail:
            return ["PRIVMSG $C$ :Parse Failure: "+str(detail)]
        conditionState=True
        toReturn=[]
        for condition in msg[0]:
            try:
                calcInput=":%s PRIVMSG %s :!%s %s"%(complete.userMask(),complete.channel(),"calculate", condition)
                inputObj=formatInput(pluginArguments(calcInput))
                output=':'.join(globalv.loadedPlugins["calculate"].action(inputObj)[0].split(':')[1:])
                if output=="False":
                    conditionState=False
                    break
            except Exception as detail:
                return ["PRIVMSG $C$ :Conditional execution failure in %s"%condition,"PRIVMSG $C$ :Reason:%s"%str(detail)]

        if conditionState==True:
            commandList=msg[1][0].split(';')
        elif len(msg[1])>1:
            commandList=msg[1][1].split(';')
        else:
            commandList=[]
        for command in commandList:
            try:
                plugin=command.split()[0]
                args=' '.join(command.split()[1:])
                input=":%s PRIVMSG %s :!%s %s"%(complete.userMask(),complete.channel(),plugin, args)
                inputObj=formatInput(pluginArguments(input))
                toReturn+=[x.replace('\x00','').encode('utf-8') for x in globalv.loadedPlugins[plugin.split()[0]].action(inputObj)]
            except Exception as detail:
                return ["PRIVMSG $C$ :!if failure in command %s"%command,"PRIVMSG $C$ :Reason:%s"%str(detail)]
        return toReturn 
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !kick module","PRIVMSG $C$ :Usage: (Requires Elevated Bot Privileges)","PRIVMSG $C$ :!kick [user]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import settingsHandler
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        list=settingsHandler.readSettingRaw("coreIgnorance","ignorance,nickname")
        laters=[]
        print list
        for line in list:
            laters.append(line[0]+((" ("+line[1]+")") if line[1]!="*Unknown*" else ""))
        if len(list)==0:
            laters=["PRIVMSG $C$ :No users ignored, cap'n!"]
        else:
            laters="PRIVMSG $C$ :"+', '.join(laters)
        return laters

    def describe(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ :I am the !laterlist module. I list all current laters.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!laterlist"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
import securityHandler
import settingsHandler
from userlevelHandler import getLevel
import os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 50
    def action(self, complete):
        msg=complete.message()
        nick=complete.userMask()
        amsg=msg
        nickname="*Unknown*"
        if securityHandler.isAllowed(nick)>=getLevel(complete.cmd()[0]):
            if msg[0]=="#":
                nmsg = msg
                nickname=""
            elif msg in globalv.miscVars[0]:
                nmsg=".*@"+globalv.miscVars[0][msg].split('@')[1]
                nickname=msg
            else:
                nmsg=msg
                nmsg=nmsg.replace('*','.*').replace('..*','.*')
            fullCMD=nmsg
            if fullCMD not in [x[0] for x in settingsHandler.readSettingRaw("coreIgnorance","ignorance")]:
                settingsHandler.writeSetting("coreIgnorance",["ignorance","nickname"],[fullCMD,nickname])
                return ["PRIVMSG $C$ :"+amsg+ " successfully ignored, cap'n!"]
            else:
                return ["PRIVMSG $C$ :"+amsg+" is already ignored, m'lord!"]
        else:
            return ["PRIVMSG $C$ :Go away."]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !ignore module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!ignore [user or regex hostmask pattern]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import socket
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        if msg.startswith("http://"):
            msg=msg[7:]
        ip=str(socket.gethostbyname(msg))
        return ["PRIVMSG $C$ :"+ip.decode('utf-8')]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
from securityHandler import isAllowed
from userlevelHandler import getLevel
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 150
    def action(self, complete):
        msg=complete.message()
        sender=complete.userMask()
        if isAllowed(sender)>=getLevel(complete.cmd()[0]):
            if msg!="":
                chan=msg
                if chan[0]!="#":
                    chan="#"+chan
                msg="JOIN "+chan
                globalv.channels.append(chan)
                return [msg]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !join module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!join #channel"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import random
from userlevelHandler import getLevel
from securityHandler import isAllowed
import re
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 100
    def action(self, complete):
        msg=complete.message()
        if isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]):
            kickMessage=' '.join(msg.split()[1:])
            if kickMessage=="":
                kickMessage="Go away."
            toKick=["KICK $C$ "+msg.split()[0]+" :"+kickMessage]
            return toKick
        else:
            kickMessage=' '.join(msg.split()[1:])
            if kickMessage=="":
                kickMessage="Go away."
            return ["PRIVMSG $C$ :ACTION kicks "+msg.split()[0]+" in the shin (%s)"%kickMessage]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !kick module","PRIVMSG $C$ :Usage: (Requires Elevated Bot Privileges)","PRIVMSG $C$ :!kick [user]"]
# -*- coding: utf-8 -*-
from plugins import pluginimport globalv,urllib2class pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()		url="http://ws.audioscrobbler.com/2.0/?method=track.search&track="+msg.replace(' ','%20')+"&api_key=2d51d7338fd13b2c1045f68e3a2ccc62"		feed=urllib2.urlopen(url).read()		name=feed.split('<name>')[1].split('</name>')[0]		artist=feed.split('<artist>')[1].split('</artist>')[0]		link=feed.split('<url>')[1].split('</url>')[0]		msg="Found \""+name+"\" by "+artist+" (at "+link+")"		return ["PRIVMSG $C$ :"+msg]	def describe(self, complete):		msg=complete.message()		return ["PRIVMSG $C$ :I am the !last.fm search module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!last.fm [track]"]# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import time
import re
import os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=str(complete.message()).strip()
        ttime=time.gmtime()
        result=""
        year=time.gmtime()[0]
        day=time.gmtime()[7]
        ignoreControlCharacters=True
        controlCharacters=['\x02', '\x1F', '\x16', '\x0F', '\x03']
        for letter in msg:
            if letter in controlCharacters:
                ignoreControlCharacters=False
        while not result:
            if not os.path.exists(os.path.join("logs","LogFile - "+complete.channel()+"-"+str(year) + "-" + str(day))):
                return ["PRIVMSG $C$ :No matches!"]
            with open(os.path.join("logs","LogFile - "+complete.channel()+"-"+str(year) + "-" + str(day))) as file:
                text=file.read()
            text=text.split('\n')
            for line in text:
                oline=line
                if ignoreControlCharacters:
                    line=re.sub("\x03\d*(,\d*)?","",line)
                    line=line.translate(None,''.join(controlCharacters))
                line=line.split('*')
                if len(line)!=1:
                    if len(line)==2:
                        line=' '.join(line[1].split()[1:])
                    else:
                        line=line[2]
                    if line.lower().find(msg.lower())!=-1:
                        if line.strip().startswith(globalv.commandCharacter)==False:
                            result=oline
            day-=1
            if day==0:
                year-=1
                day=365

        return ["PRIVMSG $C$ :"+result]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !last module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!last [phrase]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import settingsHandler
import time
from securityHandler import isAllowed
from userlevelHandler import getLevel
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __append_seperator__(self):
        return True
    def action(self, complete):
        msg=complete.message()
        command=msg.split()[0]
        if command=="list":
            names=settingsHandler.readSettingRaw("laterd","recipient, sender, timestamp", where="sent='0' AND anonymous='0'")
            returns=[]
            for name in names:
                try:
                    recipient=name[0]
                    sender=name[1]
                    timestamp=name[2]
                    ctime=time.strftime("%H:%M on %d-%m-%Y",time.gmtime(int(timestamp)))
                    message=recipient+" has a message from "+sender+" (Sent on "+ctime+")"
                    returns.append(message)
                except:
                    pass
            if returns==[]:
                returns.append("No messages.")
            return ["PRIVMSG $C$ :"+', '.join(returns)]
        elif command=="remove":
            try:
                senderString="sender=='%s' AND "%complete.user()
                if isAllowed(complete.userMask())>getLevel(complete.user()):
                    senderString=""
                settingsHandler.updateSetting("laterd","sent", "'2'", where="recipient='%s' and sent='0' and sender='%s'"%(msg.split()[1].lower(), complete.user()))
                return ["PRIVMSG $C$ :Later successfully removed!"]
            except Exception as detail:
                return ["PRIVMSG $C$ :Later not removed:"+str(detail)]
        else:
            msg=msg.replace('::',' ')
            if msg.split()[0]=="secret":
                anonymous="1"
                msg=' '.join(msg.split()[1:])
            else:
                anonymous="0"
            channels=[]
            while msg.split()[0][0]=="#":
                channels.append(msg.split()[0])
                msg=' '.join(msg.split()[1:])
            channel='|'.join(channels)
            recipients=msg.split()[0].lower().split(',')
            sender=complete.user()
            senderMask=complete.userMask()
            timestamp=str(int(time.time()))
            message=' '.join(msg.split()[1:])
            for recipient in recipients:
                print recipient
                id=str(int(settingsHandler.readSetting("laterd", "COUNT(id)"))+1)
                settingsHandler.writeSetting("laterd",["id", "recipient","sender","senderMask","timestamp","message", "channel", "anonymous",  "sent"],[id, recipient, sender, senderMask, timestamp, message, channel, anonymous, "0"])
                settingsHandler.db.commit()
            return ["PRIVMSG $C$ :Ok, I'll tell "+', '.join(recipients[:-1])+(" and "+recipients[-1] if len(recipients)>1 else recipients[-1])+" that when they next speak!"]
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !later module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!later [recipient] [plugin to run (probably say or msg)] [arguments to plugin (What to say, mostly)]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import settingsHandler
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        plugins=settingsHandler.readSetting("'core-userlevels'","plugin,level")
        returner=[]
        output=[]
        if msg=="":
            for plugin, level in plugins:
                if int(level)>0:
                    returner.append(':'.join((plugin,level)))
                out=', '.join(returner)
            output.append("PRIVMSG $C$ :"+out)
            output.append("PRIVMSG $C$ :All other functions do not require elevation")
        elif msg.split()[0]=="-list":
            if len(msg.split())==1:
                for plugin, level in plugins:
                    returner.append(':'.join((plugin,level)))
                out=', '.join(returner)
                output.append("PRIVMSG $C$:"+out)
            else:
                yes=[]
                no=[]
                if msg.split()[1].isdigit():
                    userlevel=int(msg.split()[1])
                else:
                    userlevel=settingsHandler.readSetting("autoidentifyd","level",where="nickname='%s'"%msg.split()[1])
                    if userlevel==[]:
                        userlevel="0"
                    userlevel=int(userlevel)
                for plugin, level in plugins:
                    if len(msg.split())!=2 or int(level)>0:
                        if int(level)>userlevel:
                            no.append(plugin)
                        else:
                            yes.append(plugin)
                output.append("PRIVMSG $C$ :Can use: "+', '.join(yes))
                output.append("PRIVMSG $C$ :Can not use: "+', '.join(no))
                if userlevel>=100:
                    output.append("PRIVMSG $C$ :Can not be ignored.")
                elif userlevel>=20:
                    output.append("PRIVMSG $C$ :Channelwide ignores will not take effect.")
                else:
                    output.append("PRIVMSG $C$ :All ignores take effect")

        elif msg.split()[0] in globalv.loadedPlugins.keys():
            if len(msg.split())==1:
                for plugin, level in plugins:
                    if plugin.lower()==msg.split()[0].lower():
                        output.append("PRIVMSG $C$ :"+plugin+":"+level)
            elif msg.split()[1].isdigit():
                settingsHandler.updateSetting("'core-userlevels'","level", msg.split()[1], where="plugin='%s'"%msg.split()[0])
                output.append("PRIVMSG $C$ :Altered access requirements for that plugin")
            elif msg.split()[1] in globalv.loadedPlugins.keys():
                 for plugin, level in plugins:
                    if plugin.lower()==msg.split()[1].lower():
                        newLevel=level
                        break
                 settingsHandler.updateSetting("'core-userlevels'","level", newLevel, where="plugin='%s'"%msg.split()[0])
                 output.append("PRIVMSG $C$ :Equalised plugin requirements")

        return output
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
import shlex
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __append_seperator__(self):
        return True
    def action(self, complete):
        msg=complete.message().split('::')
        if len(msg)>1:
            stdin=msg[1]
            args=msg[0]
        else:
            stdin=' '.join(complete.message().split()[1:])
            args=complete.message().split()[0]
        args=int(args)
        msg=stdin[:stdin.find(' ',args)]
        return ["PRIVMSG $C$ :"+msg+('...' if len(stdin)>args else '')]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import pluginimport globalvclass pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		plugins=globalv.loadedPlugins.keys()		plugins+=globalv.loadedSpecial.keys()		plugins+=globalv.loadedRealtime.keys()		joiner=", "+globalv.commandCharacter		msg="Loaded plugins are: "+globalv.commandCharacter+joiner.join(plugins)+". For more information, try the "+globalv.commandCharacter+"help command."		return ["PRIVMSG $C$ :"+msg]	def describe(self, complete):		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]# -*- coding: utf-8 -*-
from plugins import plugin
from settingsHandler import readSetting
from pluginHandler import load_plugin, unload_plugin
from aliasHandler import load_alias
from securityHandler import isAllowed
from userlevelHandler import getLevel
import globalv
import sys
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 50
    def action(self, complete):
        name=complete.message().split()[0]
        loadAs=""
        if len(complete.message().split())==3:
            loadAs = complete.message().split()[2]
        loadBlacklist=["special"]
        if name.lower() in loadBlacklist and isAllowed(complete.userMask())<150:
            return ["PRIVMSG $C$ :Owner only plugin!"]
        if isAllowed(complete.userMask())<getLevel(complete.cmd()[0]):
            return ["PRIVMSG $C$ :Sorry, only elevated users can load plugins!"]
        if name in globalv.loadedAliases.keys():
            try:
                extension=globalv.loadedAliases[name]
                unload_plugin(name)
                pluginName=extension.split()[0]
                x=__import__(pluginName)
                reload(x)
                globalv.loadedPlugins[pluginName]=x.pluginClass()
                load_alias(name, extension)
                msg="Reloaded alias "+name+" successfully!"
            except Exception as detail:
                msg="Load failure: "+str(detail)
        else:
            try:
                state=load_plugin(name, loadAs)
                msg="oaded "+name+" successfully!"
                msg="L"+msg if state==0 else "Rel"+msg
            except Exception as detail:
                msg="Load failure: "+str(detail)
        if complete.message().split()[1:]==["silently"]:
            return [""]
        else:
            return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !load module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!load [plugin]"]
# -*- coding: utf-8 -*-
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ :"+msg.lower()]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import os

import re

from datetime import datetime, timedelta
import time
import random
import fnmatch

def sublistIndex(l1, l2):
    if len(l1) < len(l2):
        return -1
    k = 0
    while k < len(l1):
        h = 0
        while h < len(l2) and l1[k+h] == l2[h]:
            h += 1
            if k+h >= len(l1):
                break
        if h == len(l2):
            return k
        k += 1
    return -1

class pluginClass(plugin):
    def __init__(self):
        pass
    
    def gettype(self):
        return "command"

    def tuples(self, words):
        for i in range(len(words) - self.depth):
            yield words[i:i+self.depth+1]

    def isSentenceEnd(self, word):
        return word == '.' or word == '!' or word == '?'

    def includesPhrase(self):
        return len(includedPhrase) > 0

    def tupleToLowerKey(self, t):
        return tuple(map(lambda a: a.lower(), t))

    def generateMarkovText(self, words, cache):
        depth = self.depth
        
        endMark = self.tupleToLowerKey(words[-depth:])
        
        resetAtEnd = not endMark in cache
        
        seed = random.randint(0, len(words)-depth)
        current = tuple(words[seed:seed+depth])
        genWords = []

        phrasePos = -2

        self.chainFailure = False

        if len(self.startPhrase) > 0:
            start = self.startPhrase
            genWords.extend(start[:-depth])
            current = tuple(start[-depth:])
            
            endMark2 = self.tupleToLowerKey(self.startPhrase[-depth:])
        
            self.chainFailure = not endMark2 in cache

        while len(genWords) < self.outputLen:
            genWords.append(current[0])
            
            if len(genWords) == self.outputLen-depth+1:
                genWords.extend(current[1:])
                break
            if len(genWords) > self.outputLen-depth+1:
                rem = self.outputLen - len(genWords)
                if rem > 0:
                    genWords.extend(current[1:1+rem])
                break

            key = self.tupleToLowerKey(current)
            
            if (resetAtEnd and key == endMark) or (self.chainFailure and key == endMark2) or (random.randint(0,1) == 0 and self.isSentenceEnd(key[-1][-1])):
                genWords.extend(current[1:])
                
                seed = random.randint(0, len(words)-depth)
                current = tuple(words[seed:seed+depth])
            else:
                current = current[1:] + tuple([random.choice(cache[key])])

        return ' '.join(genWords)

    def usage(self):
        return 'Usage: !markov [-words %d] [-logs %d] [-filter %s [%s [%s ...]]] [-phrase %s] [-depth %d]'

    def parseArgs(self, args):
        self.outputLen = 60
        self.daysBack = 50
        self.nickFilter = ['*']
        self.startPhrase = []
        self.depth = 2

        i = 0
        while i < len(args):
            if args[i] == '-words':
                try:
                    self.outputLen = int(args[i+1])
                    if self.outputLen > 500:
                        return ["PRIVMSG $C$ :Error: too much words. (Max value: 500)"]
                    elif self.outputLen < 0:
                        return ["PRIVMSG $C$ :Error: negative length"]
                    elif self.outputLen == 1:
                        return ["PRIVMSG $C$ :Error: length of 1 word"]
                except:
                    return ["PRIVMSG $C$ :Invalid arg %s - %s" % (args[i+1], self.usage())]
                i += 2
            elif args[i] == '-depth':
                try:
                    self.depth = int(args[i+1])
                    if self.depth > 10:
                        return ["PRIVMSG $C$ :Error: Depth too big. (Max value: 10)"]
                    elif self.depth < 1:
                        return ["PRIVMSG $C$ :Error: depth smaller than 1"]
                except:
                    return ["PRIVMSG $C$ :Invalid arg %s - %s" % (args[i+1], self.usage())]
                i += 2
            elif args[i] == '-logs':
                try:
                    self.daysBack = int(args[i+1])
                    if self.daysBack > 500:
                        return ["PRIVMSG $C$ :Error: too much logs to read. (Max value: 500)"]
                    elif self.daysBack < 0:
                        return ["PRIVMSG $C$ :Error: negative number of logs"]
                except:
                    return ["PRIVMSG $C$ :Invalid arg %s - %s" % (args[i+1], self.usage())]
                i += 2
            elif args[i] == '-filter':
                self.nickFilter = args[i+1:]
                j = 0
                while j < len(self.nickFilter):
                    if self.nickFilter[j][0] == '-':
                        self.nickFilter = self.nickFilter[:j]
                        break
                    j += 1
                    
                if len(self.nickFilter) == 0:
                    return ["PRIVMSG $C$ :Invalid argument for -filter - %s" % self.usage()]
                
                i += len(self.nickFilter)+1
            elif args[i] == '-phrase':
                self.startPhrase = args[i+1:]
                j = 0
                while j < len(self.startPhrase):
                    if self.startPhrase[j][0] == '-':
                        self.startPhrase = self.startPhrase[:j]
                        break
                    j += 1
                    
                if len(self.startPhrase) == 0:
                    return ["PRIVMSG $C$ :Invalid argument for -phrase - %s" % self.usage()]
                i += len(self.startPhrase)+1
            elif args[i][0] == '-':
                return ["PRIVMSG $C$ :Invalid option %s - %s" % (args[i], self.usage())]
            else:
                return ["PRIVMSG $C$ :Invalid usage - %s" % self.usage()]

        return []

    def action(self, complete):
        if complete.channel()[0] != '#':
            return []

        channel = complete.channel()

        parseResult = self.parseArgs(complete.message().split())
        if len(parseResult) > 0:
            return parseResult
        
        today = time.gmtime()
        today = datetime(today.tm_year, today.tm_mon, today.tm_mday) #datetime.today()

        cache = {}

        re_message = re.compile('\[.+?\] \* (?P<poster>[A-Za-z0-9_-]+) \*? (?P<words>.+)')
        re_words = re.compile('[^\s]+')

        words = []

        phraseTooShort = len(self.startPhrase) < self.depth

        fileTries = 10

        for delta in range(self.daysBack):
            day = today - timedelta(days=delta)
            doty = int(day.strftime('%j'))
            path = os.path.join("logs","LogFile - %s-%d-%d" % (channel, day.year, doty))

            try:
                with open(path) as log:
                    lines = log.readlines()
            except:
                print path, 'not found'
                
                fileTries -= 1
                if fileTries > 0:
                    continue
                else:
                    break

            log_words = []

            for line in lines:
                message = re_message.search(line)
                if not message:
                    continue
                poster = message.group('poster')
                if poster == 'OMGbot':
                    continue
                
                ignore = True
                for f in self.nickFilter:
                    if fnmatch.fnmatch(poster.lower(), f.lower()):
                        ignore = False
                        break
                
                if ignore:
                    continue
                
                message = message.group('words').strip()
                if message[0] == '!':
                    continue
                if message[-1].isalnum():
                    message += '.'

                line_words = re_words.findall(message)

                log_words.extend(line_words)

            words = log_words + words

        """possibleExtensions = []

        L = len(self.startPhrase)"""
                        
        for ws in self.tuples(words):
            key = self.tupleToLowerKey(ws[:self.depth])

            """for d in range(1, min(self.depth, L+1)):
                if self.startPhrase[-d:] == ws[0:d]:
                    possibleExtensions.append(ws[d:])"""
            
            if key in cache:
                cache[key].append(ws[-1])
            else:
                try:
                    cache[key] = [ws[-1]]
                except Exception as detail:
                    print detail
                    print ws[-1]
                    return ["PRIVMSG $C$ :%s: %s"%(detail, ws[-1])]
                
        """if random.randint(0,1) == 0 and possibleExtensions != [] and tuple(self.startPhrase[-self.depth:]) not in cache:
            self.startPhrase.extend(random.choice(possibleExtensions))
            print 'adaptation:', self.startPhrase"""

        if len(words) < self.depth+1:
            return ["PRIVMSG $C$ :Not enough words found."]

        m = self.generateMarkovText(words, cache)
        
        if not m[0].istitle():
            m = m[0].upper() + m[1:]
        if m[-1].isalnum():
            m += '.'
        else:
            m = m[:-1] + '.'

        re_url = re.compile('https?://')

        markovText = ''
        endLine = False
        for i in xrange(len(m)):
            c = m[i]
            if endLine:
                if re_url.match(m[i:i+8]):
                    markovText += c
                else:
                    markovText += c.upper()
                if c.isalnum():
                    endLine = False
            else:
                markovText += c
                if self.isSentenceEnd(c) and i < len(m) - 1 and m[i+1] == ' ':
                    endLine = True

        output = ["PRIVMSG $C$ :" + markovText]

        if self.chainFailure:
            print 'Failed to chain starting phrase.'

        return output
    
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the MARKOV CHAIN plugin",
                "PRIVMSG $C$ :%s" % self.usage(),
                "PRIVMSG $C$ :Example:",
                "PRIVMSG $C$ :!markov -words 50 -logs 40 -filter PY sirX* -depth 3 -phrase Once upon a time"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __append_seperator__(self):
        return True
    def action(self, complete):
        msg=complete.message().split('::')[0]
        if msg.split()[0][0]=="-" and msg.split()[0][1:].isdigit():
            numMatches=int(msg.split()[0][1:])
            msg=' '.join(msg.split()[1:])
        else:
            numMatches=99
        match=re.findall(msg,complete.message().split('::')[1])
        print match
        if len(match)>0:
            match=', '.join(match[:numMatches])
        else:
            match="No Matches"
        return ["PRIVMSG $C$ :"+match]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import settingsHandler
from securityHandler import isAllowed
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        if isAllowed(complete.userMask())<1:
            return [""]
        MCName=complete.message().split()[0]
        IRCName=complete.user()
        settingsHandler.writeSetting("stripMCBotNames", ["minecraft", "irc"], [MCName, IRCName])
        return ["PRIVMSG $C$ :Names linked - please reload stripMCBotNames for the changes to take effect"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import time
import re
import os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        today=time.gmtime()
        currentYear=today[0]
        currentDay=today[7]
        users={}
        total=0
        days=5
        numUsers=3
        channel=complete.channel().lower()
        userBlacklist=[]
        userWhitelist=[]
        nextCommand=""
        for command in complete.message().split():
            if nextCommand=="":
                if command=="-days":
                    nextCommand="days"
                elif command.startswith("-nu"):
                    nextCommand="numUsers"
                elif command=="-channel":
                    nextCommand="channel"
                elif command=="-not":
                    nextCommand="blacklist"
                elif command=="-find":
                    nextCommand="whitelist"
                elif command.startswith('-h'):
                    return ["PRIVMSG $C$ :Usage: %s%s [-days Number of days to search] [-num Number of users to return] [-channel Channel to search] [-not Users to exclude] [-find Users to return results for]"%(globalv.commandCharacter, complete.cmd()[0])]
            else:
                if nextCommand=="days":
                    days=int(command)
                elif nextCommand=="numUsers":
                    numUsers=int(command)
                elif nextCommand=="channel":
                    channel=command.lower()
                elif nextCommand=="blacklist":
                    userBlacklist=command.split(',')
                elif nextCommand=="whitelist":
                    userWhitelist=command.split(',')

                nextCommand=""
        last = ''
        lastTime = [1970,1,1,0,0,0,3,1,-1]
        lineCount = 0
        for offset in xrange(days):
            day=currentDay-offset
            year=currentYear
            if day <= 0:
                day+=365
                year-=1
            path=os.path.join("logs","LogFile - "+channel+"-"+str(year)+"-"+str(day))
            if not os.path.exists(path):
                continue
            data=open(path).readlines()

            for line in data:
                match=re.findall("^\[(\d.*?)\d\]\s\*\s([^\s]*)", line)
                if match==[]:
                    continue
                nickname=match[0][1]
                newtime=time.strptime(match[0][0], '%d %b %y %H:%M')

                if last==nickname and time.mktime(newtime) - time.mktime(lastTime) < 160:
                    lineCount += 1
                    if lineCount == 6:
                        if nickname in users:
                            users[nickname]+=1
                        else:
                            users[nickname]=1
                        total+=1
                else:
                    last = nickname
                    lineCount = 1
                lastTime = newtime
                
        userArray=[[key, users[key]] for key in users.keys()]
        userArray.sort(key=lambda x:x[1])
        print userBlacklist
        userArray=filter(lambda x:x[0] not in userBlacklist, userArray)
        if userWhitelist!=[]:
            userArray=filter(lambda x:x[0] in userWhitelist, userArray)
        toReturn="PRIVMSG $C$ :%s total monologues from the past %s days! Rankings:"%(total, days)
        for index in range(1,min(numUsers+1,len(userArray)+1)):
            numLines=userArray[-index][1]
            name=userArray[-index][0]
            percentage=(numLines/float(total))*100
            if percentage>1:
                percentage=int(percentage)
            toReturn+=" %s with %s%% of the chat (%s monologues);"%(name, percentage, numLines)
        return [toReturn]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]

# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        if len(globalv.outputQueue) > 0:
            message = globalv.outputQueue.pop(0)
        else:
            message = "PRIVMSG $C$ :No items in queue."
        return message.decode('utf-8')
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=' '.join(complete.message().split()[1:])
        user=complete.message().split()[0].lower()
        yeahNo=["chanserv","nickserv","memoserv"]
        if user not in yeahNo:
            return ["PRIVMSG "+user+" :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        return ["PRIVMSG $C$ :$U$"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        import random
        vowels = ('a','e','i','o','u')
        consonants = ('q','w','r','t','y','p','s','d','f','g','h','j','k','l','z','x','c','v','b','n','m','q','w','r','t','y','p','s','d','f','g','h','j','k','l','z','x','c','v','b','n','m')
        nextMustBeVowel=("x" ,"p" ,"s" ,"v" ,"j" ,"n" ,"d" ,"c" ,"b" ,"h" ,"g" ,"k")
        vowelLength=len(vowels)-1
        consonantLength=len(consonants)-1
        def generateName(number,randGen=random):
            name = mustBe = ""
            vowelOr=round(randGen.random())
            for value in xrange(0,number):
                if mustBe:
                    name+=mustBe
                    mustBe=""
                elif vowelOr>0:
                    toAdd=vowels[int(round(randGen.random()*vowelLength))]
                    name+=toAdd
                    vowelOr=0 if random.randint(0,100)<80 else 1
                else:
                    toAdd=consonants[int(round(randGen.random()*consonantLength))]
                    name+=toAdd
                    if (toAdd in nextMustBeVowel):
                        vowelOr=1
                    else:
                        vowelOr=round(randGen.random())
                if name[value]=='q':
                    mustBe="u"
            return name.capitalize()
        return ["PRIVMSG $C$ :"+generateName(int(complete.message()))]
def describe(self, complete):
    return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        return [""]
    def describe(self, complete):
        return ["PRIVMSG $C$ :TOUCH ME AND I'LL FUCK YOUR SHIT","KICK $C$ $U$ :COURTESY OF MY BIG, FAT ASS."]
# -*- coding: utf-8 -*-
from plugins import plugin
import time
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        return ["PRIVMSG $C$ :%s"%time.strftime("%H.%M")]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
# This Python file uses the following encoding: utf-8
from plugins import plugin
from bitlyServ import bitly
import globalv
import re,urllib2
import settingsHandler
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name, "IRCnick", "LASTFMnick")
    def action(self, complete):
        msg=complete.message()
        user=complete.user()
        users={}
        for nicknick in settingsHandler.readSetting(complete.cmd()[0], "IRCnick, LASTFMnick"):
            users.update({nicknick[0].lower():nicknick[1]})
        if msg!="":
            user=msg
        if len(msg.split())>=2:
            if msg.split()[0]=="-link":
                settingsHandler.writeSetting(complete.cmd()[0], ["IRCnick","LASTFMnick"], [complete.user(), ' '.join(msg.split()[1:])])
                return ["PRIVMSG $C$ :Linked %s to %s"%(complete.user(),  ' '.join(msg.split()[1:]))]
        try:
            if user.lower() in users.keys():
                name=users[user.lower()]
            else:
                name=user
            url="http://ws.audioscrobbler.com/1.0/user/"+name+"/recenttracks.rss"
            p=urllib2.urlopen(url).read()
            p=re.search("<description>Last 10 tracks submitted to Last.fm</description>(.*)</item>",p,re.DOTALL).group(1)
            l=re.search("<link>(.*?)</link>",p,re.DOTALL).group(1)
            p=re.search("<title>(.*?)</title>",p,re.DOTALL).group(1)
            if len(l)>50:
                l=bitly(l)
            p=p.split('\xe2\x80\x93')
            msg=user+" is listening to"+p[1].decode('utf-8')+" by "+p[0].decode('utf-8')+" ("+l+")"
        except:
            msg="I don't know what "+user+" is listening to. Sorry."
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !np module. I grab what a designated last.fm user is listening to!","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [OPTIONAL user|-link] [OPTIONAL last.fm nickname to link to]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        names=globalv.channelUsers[complete.channel()][:]
        return ["PRIVMSG $C$ :"+str(len(names))]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
import re

from plugins import plugin
import globalv

__version__ = '0.2.1'

cs_re = re.compile(r',\s+')
bks_re = re.compile(r'\[[0-9a-z]{2}\]')
prs_re = re.compile(r'\([0-9a-z]{2}(?:,[xy]\)|,s\),y|\))?')
jmp6_re = re.compile(r'\[[0-9a-z]{6}\]')
jmp4_re = re.compile(r'\([0-9a-z]{4}(?:,x)?\)')
label_re = re.compile(r'([\w\d]+):')
splitup_re = re.compile(r'..')

class pluginClass(plugin):

    def asm(self, token, tokens, labels):
        m = label_re.match(token)
        if m is not None:
            labels[m.group(1)] = len(tokens)
            token = token.split(None, 1)[1:]
        del m
        L = cs_re.sub(',', token).split()
        insn = L[0]
        if insn == 'db' or insn == 'data':
            return reduce(lambda x, y: x + y, [self.splitup(i) for i in L[1:]])
        if len(L) == 1:
            if insn == 'inx':
                return ['E8']
            if insn == 'iny':
                return ['C8']
            if insn == 'dex':
                return ['CA']
            if insn == 'dey':
                return ['88']
            if insn == 'pla':
                return ['68']
            if insn == 'plx':
                return ['FA']
            if insn == 'ply':
                return ['7A']
            if insn == 'pld':
                return ['2B']
            if insn == 'plb':
                return ['AB']
            if insn == 'plp':
                return ['28']
            if insn == 'tax':
                return ['AA']
            if insn == 'tay':
                return ['A8']
            if insn == 'tcs':
                return ['1B']
            if insn == 'tcd':
                return ['5B']
            if insn == 'txa':
                return ['8A']
            if insn == 'txy':
                return ['9B']
            if insn == 'txs':
                return ['9A']
            if insn == 'tya':
                return ['98']
            if insn == 'tyx':
                return ['BB']
            if insn == 'tsc':
                return ['3B']
            if insn == 'tsx':
                return ['BA']
            if insn == 'tdc':
                return ['7B']
            if insn == 'xba':
                return ['EB']
            if insn == 'clc':
                return ['18']
            if insn == 'cld':
                return ['D8']
            if insn == 'cli':
                return ['58']
            if insn == 'clv':
                return ['B8']
            if insn == 'sec':
                return ['38']
            if insn == 'sed':
                return ['F8']
            if insn == 'sei':
                return ['78']
            if insn == 'xce':
                return ['FB']
            if insn == 'nop':
                return ['EA']
            if insn == 'wdm':
                return ['42']
            if insn == 'rti':
                return ['40']
            if insn == 'rts':
                return ['60']
            if insn == 'rtl':
                return ['6B']
            if insn == 'wai':
                return ['CB']
            if insn == 'stp':
                return ['DB']
            if insn == 'pha':
                return ['48']
            if insn == 'php':
                return ['08']
            if insn == 'phx':
                return ['DA']
            if insn == 'phy':
                return ['5A']
            if insn == 'phb':
                return ['8B']
            if insn == 'phd':
                return ['0B']
            if insn == 'phk':
                return ['4B']
        if len(L) == 2:
            op = L[1]
            if insn == 'adc':
                if op[0] == '#':
                    return ['69'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['77', op[1:3]]
                    return ['67', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['73', op[1:3]]
                    if op.endswith(',x)'):
                        return ['61', op[1:3]]
                    if op.endswith(',y)'):
                        return ['71', op[1:3]]
                    return ['72', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['75', b[0]]
                    if len(b) == 2:
                        return ['7D'] + b
                    if len(b) == 3:
                        return ['7F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['79'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['63'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['65', b[0]]
                if len(op) == 2:
                    return ['6D'] + b
                if len(op) == 3:
                    return ['6F'] + b
                return [None]
            if insn == 'inc':
                if op == 'a':
                    return ['1A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['F6', op[:2]]
                    if len(op) == 6:
                        return ['FE'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['E6', op]
                if len(op) == 4:
                    return ['EE'] + self.splitup(op)
                return [None]
            if insn == 'sbc':
                if op[0] == '#':
                    return ['E9'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['F7', op[1:3]]
                    return ['E7', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['F3', op[1:3]]
                    if op.endswith(',x)'):
                        return ['E1', op[1:3]]
                    if op.endswith(',y)'):
                        return ['F1', op[1:3]]
                    return ['F2', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['F5', b[0]]
                    if len(b) == 2:
                        return ['FD'] + b
                    if len(b) == 3:
                        return ['FF'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['F9'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['E3'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['E5', b[0]]
                if len(op) == 2:
                    return ['ED'] + b
                if len(op) == 3:
                    return ['EF'] + b
                return [None]
            if insn == 'cmp':
                if op[0] == '#':
                    return ['C9'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['D7', op[1:3]]
                    return ['C7', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['D3', op[1:3]]
                    if op.endswith(',x)'):
                        return ['C1', op[1:3]]
                    if op.endswith(',y)'):
                        return ['D1', op[1:3]]
                    return ['D2', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['D5', b[0]]
                    if len(b) == 2:
                        return ['DD'] + b
                    if len(b) == 3:
                        return ['DF'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['D9'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['C3'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['C5', b[0]]
                if len(op) == 2:
                    return ['CD'] + b
                if len(op) == 3:
                    return ['CF'] + b
                return [None]
            if insn == 'cpx':
                if op[0] == '#':
                    return ['E0'] + self.splitup(op[1:])
                if len(op) == 2:
                    return ['E4', op]
                if len(op) == 4:
                    return ['EC'] + self.splitup(op)
                return [None]
            if insn == 'cpy':
                if op[0] == '#':
                    return ['C0'] + self.splitup(op[1:])
                if len(op) == 2:
                    return ['C4', op]
                if len(op) == 4:
                    return ['CC'] + self.splitup(op)
                return [None]
            if insn == 'dec':
                if op == 'a':
                    return ['3A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['D6', op[:2]]
                    if len(op) == 6:
                        return ['DE'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['C6', op]
                if len(op) == 4:
                    return ['CE'] + self.splitup(op)
                return [None]
            if insn == 'lda':
                if op[0] == '#':
                    return ['A9'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['B7', op[1:3]]
                    return ['A7', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['B3', op[1:3]]
                    if op.endswith(',x)'):
                        return ['A1', op[1:3]]
                    if op.endswith(',y)'):
                        return ['B1', op[1:3]]
                    return ['B2', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['B5', b[0]]
                    if len(b) == 2:
                        return ['BD'] + b
                    if len(b) == 3:
                        return ['BF'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['B9'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['A3'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['A5', b[0]]
                if len(op) == 2:
                    return ['AD'] + b
                if len(op) == 3:
                    return ['AF'] + b
                return [None]
            if insn == 'ldx':
                if op[0] == '#':
                    return ['A2'] + self.splitup(op[1:])
                if len(op) == 2:
                    return ['A6', op]
                if len(op) == 4:
                    return ['AE'] + self.splitup(op)
                return [None]
            if insn == 'ldy':
                if op[0] == '#':
                    return ['A0'] + self.splitup(op[1:])
                if len(op) == 2:
                    return ['A4', op]
                if len(op) == 4:
                    return ['AC'] + self.splitup(op)
                return [None]
            if insn == 'ora':
                if op[0] == '#':
                    return ['09'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['17', op[1:3]]
                    return ['07', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['13', op[1:3]]
                    if op.endswith(',x)'):
                        return ['01', op[1:3]]
                    if op.endswith(',y)'):
                        return ['11', op[1:3]]
                    return ['12', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['15', b[0]]
                    if len(b) == 2:
                        return ['1D'] + b
                    if len(b) == 3:
                        return ['1F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['19'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['03'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['05', b[0]]
                if len(op) == 2:
                    return ['0D'] + b
                if len(op) == 3:
                    return ['0F'] + b
                return [None]
            if insn == 'and':
                if op[0] == '#':
                    return ['29'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['37', op[1:3]]
                    return ['27', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['33', op[1:3]]
                    if op.endswith(',x)'):
                        return ['21', op[1:3]]
                    if op.endswith(',y)'):
                        return ['31', op[1:3]]
                    return ['32', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['35', b[0]]
                    if len(b) == 2:
                        return ['3D'] + b
                    if len(b) == 3:
                        return ['3F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['39'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['23'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['25', b[0]]
                if len(op) == 2:
                    return ['2D'] + b
                if len(op) == 3:
                    return ['2F'] + b
                return [None]
            if insn == 'bit':
                if op[0] == '#':
                    return ['89'] + self.splitup(op[1:])
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['34', op[:2]]
                    if len(op) == 6:
                        return ['3C'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['24', op]
                if len(op) == 4:
                    return ['2C'] + self.splitup(op)
                return [None]
            if insn == 'eor':
                if op[0] == '#':
                    return ['49'] + self.splitup(op[1:])
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['57', op[1:3]]
                    return ['47', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['53', op[1:3]]
                    if op.endswith(',x)'):
                        return ['41', op[1:3]]
                    if op.endswith(',y)'):
                        return ['51', op[1:3]]
                    return ['52', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['55', b[0]]
                    if len(b) == 2:
                        return ['5D'] + b
                    if len(b) == 3:
                        return ['5F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['59'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['43'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['45', b[0]]
                if len(op) == 2:
                    return ['4D'] + b
                if len(op) == 3:
                    return ['4F'] + b
                return [None]
            if insn == 'asl':
                if op == 'a':
                    return ['0A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['16', op[:2]]
                    if len(op) == 6:
                        return ['1E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['06', op]
                if len(op) == 4:
                    return ['0E'] + self.splitup(op)
                return [None]
            if insn == 'rol':
                if op == 'a':
                    return ['2A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['36', op[:2]]
                    if len(op) == 6:
                        return ['3E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['26', op]
                if len(op) == 4:
                    return ['2E'] + self.splitup(op)
                return [None]
            if insn == 'lsr':
                if op == 'a':
                    return ['4A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['56', op[:2]]
                    if len(op) == 6:
                        return ['5E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['46', op]
                if len(op) == 4:
                    return ['4E'] + self.splitup(op)
                return [None]
            if insn == 'ror':
                if op == 'a':
                    return ['6A']
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['76', op[:2]]
                    if len(op) == 6:
                        return ['7E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['66', op]
                if len(op) == 4:
                    return ['6E'] + self.splitup(op)
                return [None]
            if insn == 'sep':
                if op[0] == '#':
                    return ['E2', op[1:3]]
                return [None]
            if insn == 'rep':
                if op[0] == '#':
                    return ['C2', op[1:3]]
                return [None]
            if insn == 'jmp':
                if jmp6_re.match(op):
                    return ['DC'] + self.splitup(op[1:-1])
                if jpm4_re.match(op):
                    if op.endswith(',x)'):
                        return ['7C'] + self.splitup(op[1:5])
                    return ['6C'] + self.splitup(op[1:5])
                if len(op) == 4:
                    return ['4C'] + self.splitup(op)
                if len(op) == 6:
                    return ['5C'] + self.splitup(op)
                return [None]
            if insn == 'jml':
                return ['5C'] + self.splitup(op)
            if insn == 'jsr':
                if insn.startswith('(') and insn.endswith(',x)'):
                    return ['FC'] + self.splitup(op[1:5])
                if len(insn) == 4:
                    return ['20'] + self.splitup(op)
                if len(insn) == 6:
                    return ['22'] + self.splitup(op)
                return [None]
            if insn == 'jsl':
                return ['22'] + self.splitup(op)
            if insn == 'bra':
                if op in labels:
                    return ['label ' + token, '']
                if len(op) == 2:
                    return ['80', op]
                return [None]
            if insn == 'brl':
                if op in labels:
                    return ['label ' + token, '', '']
                return ['82'] + self.splitup(op)
            if insn == 'bcc':
                if op in labels:
                    return ['label ' + token, '']
                return ['90', op]
            if insn == 'bcs':
                if op in labels:
                    return ['label ' + token, '']
                return ['B0', op]
            if insn == 'beq':
                if op in labels:
                    return ['label ' + token, '']
                return ['F0', op]
            if insn == 'bne':
                if op in labels:
                    return ['label ' + token, '']
                return ['D0', op]
            if insn == 'bmi':
                if op in labels:
                    return ['label ' + token, '']
                return ['30', op]
            if insn == 'bpl':
                if op in labels:
                    return ['label ' + token, '']
                return ['10', op]
            if insn == 'bvc':
                if op in labels:
                    return ['label ' + token, '']
                return ['50', op]
            if insn == 'bvs':
                if op in labels:
                    return ['label ' + token, '']
                return ['70', op]
            if insn == 'cop':
                return ['02', op]
            if insn == 'brk':
                return ['00', op]
            if insn == 'sta':
                if bks_re.match(op):
                    if op.endswith(',y'):
                        return ['97', op[1:3]]
                    return ['87', op[1:3]]
                if prs_re.match(op):
                    if op.endswith(',y'):
                        return ['93', op[1:3]]
                    if op.endswith(',x)'):
                        return ['81', op[1:3]]
                    if op.endswith(',y)'):
                        return ['91', op[1:3]]
                    return ['92', op[1:3]]
                if op.endswith(',x'):
                    op = op.rsplit(',', 1)[0]
                    b = self.splitup(op)
                    if len(b) == 1:
                        return ['95', b[0]]
                    if len(b) == 2:
                        return ['9D'] + b
                    if len(b) == 3:
                        return ['9F'] + b
                    return [None]
                if op.endswith(',y'):
                    return ['99'] + self.splitup(op[:-2])
                if op.endswith(',s'):
                    return ['83'] + self.splitup(op[:-2])
                b = self.splitup(op)
                if len(op) == 1:
                    return ['85', b[0]]
                if len(op) == 2:
                    return ['8D'] + b
                if len(op) == 3:
                    return ['8F'] + b
                return [None]
            if insn == 'stx':
                if op.endswith(',y'):
                    return ['96', op[:2]]
                if len(op) == 2:
                    return ['86', op]
                if len(op) == 4:
                    return ['8E'] + self.splitup(op)
                return [None]
            if insn == 'sty':
                if op.endswith(',x'):
                    return ['94', op[:2]]
                if len(op) == 2:
                    return ['84', op]
                if len(op) == 4:
                    return ['8C'] + self.splitup(op)
                return [None]
            if insn == 'stz':
                if op.endswith(',x'):
                    if len(op) == 4:
                        return ['74', op[:2]]
                    if len(op) == 6:
                        return ['9E'] + self.splitup(op[:4])
                    return [None]
                if len(op) == 2:
                    return ['64', op]
                if len(op) == 4:
                    return ['9C'] + self.splitup(op)
                return [None]
            if insn == 'tsb':
                if len(op) == 2:
                    return ['04', op]
                if len(op) == 4:
                    return ['0C'] + self.splitup(op)
                return [None]
            if insn == 'trb':
                if len(op) == 2:
                    return ['14', op]
                if len(op) == 4:
                    return ['1C'] + self.splitup(op)
                return [None]
            if insn == 'pea':
                return ['F4'] + self.splitup(op)
            if insn == 'pei':
                return ['D4'] + self.splitup(op)
            if insn == 'per':
                return ['62'] + self.splitup(op)
            return [None]
        if len(L) == 3:
            if insn == 'mvn':
                return ['54', L[2], L[1]]
            if insn == 'mvp':
                return ['44', L[2], L[1]]
            return [None]
        return [None]

    def splitup(self, op):
        return splitup_re.findall('0' + op if len(op) & 1 else op)
    
    def gettype(self):
        return 'command'
    
    def action(self, complete):
        msg = []
        tokens = complete.message().lower().replace('$', '').split(';')
        labels = {}
        for i in xrange(len(tokens)):
            token = tokens[i].strip()
            m = label_re.match(token)
            if m is not None:
                labels[m.group(1)] = None
        for token in tokens:
            token = token.strip()
            asm = self.asm(token, msg, labels)
            if None in asm:
                return ['PRIVMSG $C$ :Error: failed token: ' + token]
            msg.extend(asm)
        for i in xrange(len(msg)):
            token = msg[i]
            if token.startswith('label '):
                subs = tuple(token[6:].split())
                label = labels[subs[1]]
                print 'subs: %r   label: %r   i: %r' % (subs, label, i)
                if subs[0] == 'brl':
                    delta = label - (i + 3)
                    if not (delta &~ 65535):
                        b = self.splitup(hex(delta & 65535)[2:].zfill(4))
                        msg[i] = '82'
                        msg[i + 1] = b[0]
                        msg[i + 2] = b[1]
                        continue
                    else:
                        return ['PRIVMSG $C$ :Error: label too far: brl ' +
                                subs[1]]
                delta = label - (i + 2)
                if not (delta &~ 255):
                    b = subs[0] + ' ' + hex(delta & 255)[2:].zfill(2)
                    print repr(b)
                    msg[i:i + 2] = self.asm(b, msg, labels)
                    continue
                else:
                    return ['PRIVMSG $C$ :Error: label too far: %s %s' % subs]
        print 'msg: %r' % msg
        return ['PRIVMSG $C$ :' + ' '.join(msg).upper()]
    
    def describe(self, complete):
        return [
            'PRIVMSG $C$ :65816 Assembler Module version %s' % __version__,
            'PRIVMSG $C$ :Copyright 2011 Branden Brown (a.k.a. zephyrtronium, '
            'uNsane, smlaxy, etc.)',
            "PRIVMSG $C$ :PJBoy's 65816 opcode list was referenced in order "
            'to write this: http://interdpth.arc-nova.org/PJs%20stuff/Lists'
            '/65816%20opcodes.txt',
            ]
# -*- coding: utf-8 -*-
from plugins import plugin
from securityHandler import isAllowed
from userlevelHandler import getLevel
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 100
    def action(self, complete):
        msg=complete.message()
        channel=complete.channel()
        sender=complete.userMask()
        if isAllowed(sender)>=getLevel(complete.cmd()[0]):
            if msg!="":
                chan=msg
                if chan[0]!="#":
                    chan="#"+chan
                msg="PART "+chan
                try:
                    globalv.channels.remove(chan)
                except:
                    pass
            else:
                msg="PART "+channel
            return [msg]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv, urllib2,urllib
import time
import datetime
import os
import re
import sys
sys.path.append("/home/py/.python/")
import datetime, dateutil.parser
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        arguments=complete.message().split()
        channel=complete.channel()
        msg=0
        perm=0
        timeFrom="00:00"
        hideUrls = False
        userPrint=[]
        print arguments

        for argument in arguments:
            print argument
            attemptedDate=False
            try:
                attemptedDate=dateutil.parser.parse(argument, dayfirst=True)
            except:
                pass #Awful practice, I know, but if dateparser fails it's probably because it wasn't given a date
            if argument.isdigit()==True and argument.find(':')==-1:
                msg=argument
                print "Got offset"
            elif attemptedDate!=False and argument.find(':')==-1:
                delta=(datetime.datetime.today()-attemptedDate)
                msg=delta.days
                print "Worked out offset", msg
            elif argument[0]=='#':
                channel=argument
                print "Figured channel"
            elif argument=="permanent":
                perm=1
                print "Set permenent"
            elif re.findall("[0-9]?[0-9]:[0-9][0-9]",argument)!=[]:
                timeFrom=re.findall("[0-9][0-9]:[0-9][0-9]",argument)[0]
                print "Got time"
            elif argument.lower()=="hideurls":
                hideUrls = True
            else:
                userPrint.append(argument)
                print "Got User"
        now=time.gmtime()
        year=now[0]
        day=now[7]-int(msg)
        while day<=0:
            year-=1
            day+=365
        output=[]
        cday=(datetime.date.today() - datetime.timedelta(int(msg))).day
        cmonth=(datetime.date.today() - datetime.timedelta(int(msg))).month
        fromTime=datetime.datetime(year,cmonth, cday, int(timeFrom.split(':')[0]), int(timeFrom.split(':')[1]))
        path=os.path.join("logs","LogFile - "+channel.lower()+"-"+str(year)+"-"+str(day))
        if not os.path.exists(path):
            return ["PRIVMSG $C$ :I have no logs for that day!"]
        with open(path) as file:
            for line in file.readlines():
                ctime=re.findall("[0-9][0-9]:[0-9][0-9]",line)
                if ctime!=[]:
                    ctime=ctime[0]
                    dtime=datetime.datetime(year,cmonth, cday, int(ctime.split(':')[0]), int(ctime.split(':')[1]))
                    try:
                        lineUser=line.split('*')[1].strip()
                    except Exception as detail:
                        lineUser=""
                    if dtime>=fromTime and (lineUser in userPrint or userPrint==[]):
                        if hideUrls:
                            line = line.replace('www.', 'www .').replace('http://', 'http ://').replace('https://', 'https ://')
                        output.append(line.strip())
        readFile='\n'.join(output)
        readFile="Log of %s on %s\n"%(channel,"%s-%s-%s"%(cday, cmonth, year))+readFile
        data={"paste_code":readFile,"paste_private":1,"paste_expire_date":"1H"}
        if perm:
            data["paste_expire_date"]="N"
        data=urllib.urlencode(data)
        req = urllib2.Request("http://pastebin.com/api_public.php", data)
        response = urllib2.urlopen(req)
        msg=response.read()
        print msg
        return ["PRIVMSG $C$ :"+msg+(" (Permanently)" if perm else " (Expires in 10 minutes)")+(" (URLs obfuscated to avoid spamfilter)" if hideUrls else "")]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !pastebinLogs module. I return a pastebin URL with the logs of today - [msg].","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!pastebinLogs [offset]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv, urllib2,urllib
import time
import datetime
import os
import re
import sys
sys.path.append("/home/py/.python/")
import datetime, dateutil.parser
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        readFile=complete.message()
        data={"paste_code":readFile,"paste_private":1,"paste_expire_date":"1H"}
        data=urllib.urlencode(data)
        req = urllib2.Request("http://pastebin.com/api_public.php", data)
        response = urllib2.urlopen(req)
        msg=response.read()
        print msg
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !pastebinLogs module. I return a pastebin URL with the logs of today - [msg].","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!pastebinLogs [offset]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import Image, ImageDraw, ImageFont
import urllib
import math
import pickle
import sys
import os

def _cmp_(a,b):
    if a[1]<b[1]:
        return 1
    if a[1]>b[1]:
        return -1
    if a[0]>b[0]:
        return 1
    if a[0]<b[0]:
        return -1
    return 0

class pluginClass(plugin):
    def __init__(self):
        self.charIgnore = '!#*()"\'?,.:\x01\x02\xff\x16\t\r\n'
        self.exceptions = [':)',':(','=)','=(',':|','>:(','>:)','._.',':\'(']

    def gettype(self):
        return "command"
        
    def action(self,complete):
        channel = complete.channel()
                
        words = complete.message().split()
        try:
            if len(words)>0:
                search_terms = []
                width = None
                height = None
                c = 0
                for word in words:
                    if word == '-search':
                        c = 10
                    elif c <= 1 and word.isdigit():
                        if c == 0:
                            width = int(word)
                        else:
                            height = int(word)
                        c += 1
                    elif c == 10:
                        search_terms.append(word.lower())
                    
                if width == None:
                    width,height = 1600,900
                elif height == None:
                    height = width
                        
                if words[0] == channel or words[0].isdigit():
                    return self.showPicture(os.path.join('config','picturelogs','picturelog-%s'%channel),channel,width,height, search_terms)
                else:
                    return self.showPicture(os.path.join('config','picturelogs','picturelog-%s-%s'%(channel,words[0])),channel+"-"+words[0],width,height, search_terms)
            else:
                return self.showPicture(os.path.join('config','picturelogs','picturelog-%s'%channel),channel,1600,900, [])
        except Exception as detail:
            print detail
            return ["PRIVMSG $C$ :Error: dimensions too big."]

    def showPicture(self, logpath, name, width,height, search_terms):
        print logpath
        if os.path.exists(logpath):
            with open(logpath) as logFile:
                words_dict = pickle.load(logFile)
        else:
            return ["PRIVMSG $C$ :He/she hasn't said anything yet or isn't registered/identified!"]

        filepath = os.path.join('config','picture-%s.png'%name)
        
        words = words_dict.items()
        words.sort(_cmp_)
        maxc = words[0][1]

        FONTPATH = '/usr/share/fonts/truetype/ttf-dejavu/DejaVuSans-Bold.ttf'

        img = Image.new("RGB",(width,height),(255,255,255))
        g = ImageDraw.Draw(img)
        
        x,y = 0,height/2
        bottom,top = 0,0
        first = True
        d = 0
        up = True
        prevr = 1
        f = ImageFont.truetype(FONTPATH,50)
        
        for word,count in [(x_,y_) for x_,y_ in words]:
            r = int((50*math.log(count+1))/math.log(maxc+1))
            word_ = ' '+word+' '
            if prevr != r:
                f = ImageFont.truetype(FONTPATH,r)
            prevr = r
            size = g.textsize(word_, f)
            w,h = size
            
            if first:
                bottom = y+h/2.5
                top = y-h/2.5
                first = False
                
            if x+w > width and x > 0:
                x = 0
                if up:
                    y = top-h/2.5
                    top = y-h/2.5
                    d+=8
                else:
                    y = bottom+h/2.5
                    bottom = y+h/2.5
                up = not up
                if bottom >= height and top <= 0:
                    break
            if word in search_terms:
                g.text((x,y-h/2), word_, (255,0,0), f)
            elif word_.find('://')>=0:
                g.text((x,y-h/2), word_, (d,d,255), f)
            else:    
                g.text((x,y-h/2), word_, (d,d,d), f)
            x += w
            
        img.save("/home/py/public_html/channelImages/picture-%s.png"%name,"PNG")
        return ['PRIVMSG $C$ :http://terminus.mrflea.net:81/~py/channelImages/picture-%s.png'%urllib.quote(name)]

    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the picture module! Say !picture to see a piece of art made by you talking!"]
# -*- coding: utf-8 -*-
from plugins import plugin
from pluginArguments import pluginArguments
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        arguments=pluginArguments("no!body@nowhere PRIVMSG #nothing :!ocr kindred")
        result=globalv.loadedPlugins['ocr'].action(arguments)
        return ["PRIVMSG $C$ :"+result[0]]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import urllib2
import urllib
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        message=[]
        if msg in globalv.aliasExtensions:
            if globalv.aliasExtensions[msg]!="":
                message.append("PRIVMSG $C$ :"+msg+" is an alias to a plugin, with arguments: "+globalv.aliasExtensions[msg])
        try:
            output=globalv.loadedPlugins[msg].describe(complete)
            message+=output
        except:
            try:
                output=globalv.loadedRealtime[msg].describe(complete)
                message+=output
            except Exception as detail:
                print detail
                message.append("PRIVMSG $C$ :"+"Syntax: "+globalv.commandCharacter+complete.cmd()[0]+" [command]")
                plugins=globalv.loadedPlugins.keys()
                data={"paste_code":globalv.commandCharacter+", !".join(plugins),"paste_private":1,"paste_expire_date":"1H"} 
                data=urllib.urlencode(data)
                req = urllib2.Request("http://pastebin.com/api_public.php", data)
                response=urllib2.urlopen(req).read()
                message.append("PRIVMSG $C$ :Loaded commands: %s"%response)
        return message
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !help module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!help [plugin/alias]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import urllib2, urllib
import re
from settingsHandler import readSetting
class pluginClass(plugin):
    def __init_db_tables__(self,name):
        import settingsHandler
        settingsHandler.newTable(name, "url", "regex","numMatches","matchText")
        settingsHandler.writeSetting(name,["url","regex","numMatches","matchText"],["http://google.com/complete/search?output=toolbar&q=$*$",".*","1","Autocomplete Results:"])
    def gettype(self):
        return "command"
    def action(self, complete):
        argument=complete.message().replace(' ','%20')
        url=readSetting(complete.cmd()[0],"url")
        regex=readSetting(complete.cmd()[0],"regex")
        numReturns=int(readSetting(complete.cmd()[0],"numMatches"))
        page=urllib2.urlopen(url.replace('$*$',argument)).read()
        matches=re.findall(regex,page, re.DOTALL)
        try:
            matches=[re.sub("<.*?>","",match).replace('\n','').replace('\r','') for match in matches]
            #matches=[re.sub("x3c.*?x3e","",match) for match in matches]
        except Exception as detail:
            print detail
            print "printRegexMatchFromWebpage didn't go so well in the removing HTML tags thing"
        ret=[]
        if readSetting(complete.cmd()[0],"matchText")!="":
            ret.append(readSetting(complete.cmd()[0],"matchText")) 
        for i in range(min(len(matches), numReturns)):
            if type(matches[i])==str:
                ret.append(re.sub("[^a-zA-Z0-9.,{}()[\]?\\/!\"$%^&*:;@'~#<>=+\-\s]","",matches[i]))
            elif type(matches[i])==tuple:
                ret.append(' '.join(matches[i]))
        if ret==[]:
            ret.append("No matches.")
        ret=["PRIVMSG $C$ :"+r.decode('utf-8') for r in ret]
        return ret
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !printRegexMatchFromWebpage module. I print out strings from a web page that match a regular expression.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!printRegexMatchFromWebpage [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from securityHandler import isAllowed
from settingsHandler import readSetting
from userlevelHandler import getLevel
import globalv
class pluginClass(plugin):
    def __level__(self):
        return 200
	def __init_db_tables__(self,name):
		import settingsHandler
		settingsHandler.newTable(name,"userRequirement")
		settingsHandler.writeSetting(name,"userRequirement","elevated")
	def gettype(self):
		return "command"
	def action(self, complete):
		msg=complete.message()
		sender=complete.userMask()
		userAllowed=(isAllowed(sender)>=getLevel(complete.cmd()[0])) if readSetting(complete.cmd()[0],"userRequirement")=="elevated" else sender==readSetting(complete.cmd()[0],"username") if readSetting(complete.cmd()[0],"userRequirement")=="owner" else 1
		if userAllowed:
			if msg=="":
				msg="QQ"
			return ["QUIT :"+msg]
		else:
			return ["KICK $C$ $U$ :Yeah, no."]
	def describe(self, complete):
		msg=complete.message()
		sender=complete[0].split(' ')
		sender=sender[2]
		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
from securityHandler import isAllowed
from userlevelHandler import getLevel
import re
import random
import settingsHandler
import os
import urllib
import urllib2
class pluginClass(plugin):
    def __level__(self):
        return 50
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name, "quotesLocation", "userRequirementAdd","userRequirementRemove")
        settingsHandler.writeSetting(name,["quotesLocation","userRequirementAdd","userRequirementRemove"],[name,"None","elevated"])
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        nick=complete.userMask()
        sender=complete.channel()
        amsg=msg
        if not os.path.exists(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt")):
            file=open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"),"w")
            file.close()
        if msg=="":
            zozo = open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'r')
            lines = zozo.read()
            zozo.close()
            lines=lines.split('\n\n')[:-1]
            retNum=random.randint(0,len(lines)-1)
            returner=["PRIVMSG $C$ :Quote #"+str(retNum+1)+" of "+str(len(lines))+":"]
            for line in lines[retNum].split('\n'):
                returner.append("PRIVMSG $C$ :"+str(line))
            return returner
        elif msg.split()[0].isdigit():
            msg=msg.split()[0]
            quotes = open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'r')
            lines = quotes.read()
            quotes.close()
            lines=lines.split('\n\n')[:-1]
            retNum=int(msg)
            if retNum>len(lines):
                return ["PRIVMSG $C$ :There is no quote #"+str(retNum)]
            returner=["PRIVMSG $C$ :Quote #"+str(retNum)+" of "+str(len(lines))+":"]
            for line in lines[retNum-1].split('\n'):
                returner.append("PRIVMSG $C$ :"+str(line.decode('utf-8')))
            return returner
        elif msg.split()[0]=="modify":
            quoteNum=int(msg.split()[1])-1
            toAppend=' '.join(msg.split()[2:])
            quotes = open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'r')
            lines = quotes.read()
            quotes.close()
            lines=lines.split('\n\n')[:-1]
            if int(quoteNum)>len(lines):
                return ["PRIVMSG $C$ :There is no quote #"+str(retNum)]
            lines[int(quoteNum)]=toAppend.replace('| ','\n')
            quotes = open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'w')
            quotes.write('\n\n'.join(lines)+'\n\n')
            quotes.close()
            return ["PRIVMSG $C$ :Modified that quote!"] 

        elif msg.split()[0]=="append":
            quoteNum=int(msg.split()[1])-1
            toAppend=' '.join(msg.split()[2:])
            quotes = open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'r')
            lines = quotes.read()
            quotes.close()
            lines=lines.split('\n\n')[:-1]
            if int(quoteNum)>len(lines):
                return ["PRIVMSG $C$ :There is no quote #"+str(retNum)]
            lines[int(quoteNum)]+=toAppend.replace('| ','\n')
            quotes = open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'w')
            quotes.write('\n\n'.join(lines)+'\n\n')
            quotes.close()
            return ["PRIVMSG $C$ :Appended onto that quote!"] 

        elif msg.split()[0].lower()=="dump":
            quotes = open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'r')
            data={"paste_code":quotes.read()}
            data=urllib.urlencode(data)
            req = urllib2.Request("http://pastebin.com/api_public.php", data)
            response = urllib2.urlopen(req)
            msg=response.read()
            return ["PRIVMSG $C$ :"+msg]
        else:
            allowedRemove=(isAllowed(nick)>=getLevel(complete.cmd()[0])) if settingsHandler.readSetting(complete.cmd()[0],"userRequirementRemove")=="elevated" \
                    else complete.user()==settingsHandler.readSetting("core","owner") if settingsHandler.readSetting(complete.cmd()[0],"userRequirementRemove")=="owner" else 1
            allowedAdd=(isAllowed(nick)>=getLevel(complete.cmd()[0])) if settingsHandler.readSetting(complete.cmd()[0],"userRequirementAdd")=="elevated" \
                    else complete.user()==settingsHandler.readSetting("core","owner") if settingsHandler.readSetting(complete.cmd()[0],"userRequirementAdd")=="owner" else 1
            if msg.split()[0].lower()=="remove" and allowedRemove:
                with open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'r') as file:
                    lines = file.read()
                lines=lines.split('\n\n')
                lines.pop(int(msg.split()[1])-1)
                with open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"),'w') as file:
                    file.write('\n\n'.join(lines))
                return ["PRIVMSG $C$ :Alright, removed that quote!"]
            elif msg.split()[0].lower()=="add" and allowedAdd:
                msg=' '.join(msg.split()[1:])
                zozo = open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'r')
                lines = zozo.read()
                zozo.close()
                lines=lines.split('\n\n')
                fullCMD=msg.replace(' | ','\n')
                file = open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'a')
                file.write(fullCMD + "\n\n")
                file.close()
                return ["PRIVMSG $C$ :Quote added as #"+str(len(lines))]
        if len(msg.split())>0:
            with open(os.path.join("config",settingsHandler.readSetting(complete.cmd()[0],"quotesLocation")+".txt"), 'r') as file:
                fileLines = file.read()
            lines=[]
            for index, line in enumerate(fileLines.split('\n\n')):
                lines.append((index, line))
            random.shuffle(lines)
            if msg.split()[0]=="find":
                searchFor=' '.join(msg.lower().split()[1:])
            else:
                searchFor=msg

            for index, line in lines:
                if line.lower().find(searchFor)!=-1:
                    returner=[]
                    returner.append("PRIVMSG $C$ :Quote #%s of %s:"%(index+1, len(lines)-1))
                    for l in line.split('\n'):
                        returner.append("PRIVMSG $C$ :"+l)
                    return returner
            return ["PRIVMSG $C$ :No quotes matching your input!"]
        return ["PRIVMSG $C$ :The input you have given is invalid! Try !help :)"]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !quote module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!quote [add/remove/quote index/blank] [OPTIONAL quote text or index to remove]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv,random
class pluginClass(plugin):
	def gettype(self):
		return "command"
	def action(self, complete):
		msg=complete.message()
		colour="\x03"
		msg2=''
		i=random.randint(3,12)
		for letter in msg:
			msg2+=colour+str(i).rjust(2,"0")+letter
			i= i+1 if i<12 else 3
		return ["PRIVMSG $C$ :"+msg2+"\x03"]
	def describe(self, complete):
		msg=complete.message()
		sender=complete[0].split(' ')
		sender=sender[2]
		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv,random
class pluginClass(plugin):
	def gettype(self):
		return "command"
	def action(self, complete):
		msg=complete.message()
		return ["PRIVMSG $C$ :\x03"+str(random.randint(2,12))+msg]
	def describe(self, complete):
		msg=complete.message()
		sender=complete[0].split(' ')
		sender=sender[2]
		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import time
import random
import os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message().strip()
        ttime=time.gmtime()
        result=""
        year=time.gmtime()[0]
        day=time.gmtime()[7]
        results=[]
        channel=complete.channel() if msg=="" else msg
        while not result:
            if not os.path.exists(os.path.join("logs","LogFile - "+channel+"-"+str(year) + "-" + str(day))):
                result="break!"
                break
            with open(os.path.join("logs","LogFile - "+channel+"-"+str(year) + "-" + str(day))) as file:
                text=file.read()
            text=text.split('\n')
            results+=text
            day-=1
            if day==0:
                year-=1
                day=365
        random.shuffle(results)
        result=results[0]
        return ["PRIVMSG $C$ :"+result]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !last module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!last [phrase]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import random
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        names=globalv.channelUsers[complete.channel()][:]
        random.shuffle(names)
        return ["PRIVMSG $C$ :"+names[0]]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
import htmllib
import random
import urllib2,urllib
import settingsHandler
import random

def unescape(s):
    p = htmllib.HTMLParser(None)
    p.save_bgn()
    p.feed(s)
    return p.save_end()

class pluginClass(plugin):
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name, "showTitle","showLink","showLyrics","showPreview")
        settingsHandler.writeSetting(name,["showTitle","showLink","showLyrics","showPreview"],["True","False","False","False"])
    def __init__(self):
        url = 'http://ocremix.org/'
        response = urllib2.urlopen(url)
        page = response.read()
        result = re.findall("<a href=\"/remix/OCR([0-9]*)/\">", page)
        result.sort()
        self.songID=int(result[-1])
    def gettype(self):
        return "command"
    def action(self, complete):
        def isNumber(string):
            try:
                int(string)
                return True
            except:
                return False
        msg=complete.message()
        showTitle=True if settingsHandler.readSetting(complete.cmd()[0],"showTitle")=="True" else False
        showLink=True if settingsHandler.readSetting(complete.cmd()[0],"showLink")=="True" else False
        showLyrics=True if settingsHandler.readSetting(complete.cmd()[0],"showLyrics")=="True" else False
        showPreview=True if settingsHandler.readSetting(complete.cmd()[0],"showPreview")=="True" else False
        songID=random.randint(0,self.songID)+1
        page=False
        try:
            if msg!="" and msg!="latest":
                if isNumber(msg)==False:
                    url="http://ocremix.org/quicksearch/remix/?qs_query="+msg.replace(' ','+')
                    response = urllib2.urlopen(url)
                    page=response.read() 
                    ID=re.findall("<a href=\"/remix/OCR([0-9]*)/\" ",page)
                    songID=int(ID[0])
                elif int(msg)>0:
                    songID=int(msg)
                else:
                    print songID, self.songID
                    songID=self.songID+int(msg)

            elif msg=="latest":
                url = 'http://ocremix.org/'
                response = urllib2.urlopen(url)
                page = response.read()
                result = re.findall("<a href=\"/remix/OCR([0-9]*)/\">", page)
                result.sort()
                self.songID=int(result[-1])
                songID=self.songID
            page=False
            while page==False:
                try:
                    url="http://ocremix.org/remix/OCR"+str(songID).rjust(5,"0")+"/"
                    response = urllib2.urlopen(url)
                    page=response.read()
                except:
                    songID=random.randint(0,self.songID)+1
            remixer=re.findall("ReMixer\(s\)</strong>:.(.*?)</li>",page)
            remixer=re.findall("<a href=[^>]*>([^<]*)</a>",''.join(remixer))
            remixed=re.findall("Song\(s\)</strong>:.(.*?)</li>",page)
            remixed=re.findall("<a href=[^>]*>([^<]*)</a>",''.join(remixed))
            albumName=re.findall("Album</strong>: Featured on.(.*?)</li>",page)
            if albumName!=[]:
                albumName=re.findall("<a href=[^>]*>([^<]*)</a>",''.join(albumName))[0]
            else:
                albumName=""
            links=re.findall("<a href=\"(.*?)\">Download from .*?</a>",page)
            random.shuffle(links)
            remixer=', '.join(remixer)
            remixed=', '.join(remixed)
            result = re.findall("<title>([^<]*)</title>", page)
            title=result[0]
            title='-'.join(title.split(' - ')[:-1])
            try:
                if showLyrics:
                    lyrics=re.findall('<div id="panel-lyrics" style="display:none;">(.*?)</div>',page.replace('\n','||'))[0]
                    lyrics=re.sub("<.*?>","",lyrics)
                    lyrics=re.sub("^[\|\s]+","",lyrics).replace('||','\n')
                    if re.findall("[a-zA-Z]",lyrics)==[]:
                        lyricsLink=""
                        raise Exception("Lyrics empty!")
                    data={"paste_code":lyrics,"paste_private":1,"paste_expire_date":"10M"}
                    data=urllib.urlencode(data)
                    request=urllib2.Request("http://pastebin.com/api_public.php",data)
                    lyricsLink=" - "+urllib2.urlopen(request).read()
                else:
                    lyricsLink=""
            except:
                lyricsLink=""
            previewLink=" - http://youtube.com/watch?v="
            youtubeURL=re.findall("http://www.youtube.com/v/(.*?)&",page)
            if youtubeURL!=[] and showPreview:
                previewLink+=youtubeURL[0]
            else:
                previewLink=""
            output=("\x0312Random" if msg=="" else "\x0313Returned")+" OC Remix\x03: OCR"+str(songID).rjust(5,"0")+", "+(("\x0312"+title+'\x03 of \x0312'+remixed+'\x03 by \x0312'+remixer+'\x03'+((' from \x0312'+albumName+'\x03') if albumName!="" else "")+' - ') if showTitle==True else "")+(url if showLink==False else links[0]) + lyricsLink + previewLink
        except Exception as detail:
            detail=str(detail)
            if detail=="HTTP Error 404: Not Found":
                failureReason="404: Song not found"
            elif detail=="list index out of range":
                failureReason="No results"
            else:
                failureReason=detail
            output="No OC Remix: "+failureReason
        return ["PRIVMSG $C$ :"+output.decode('utf-8')]
    def describe(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ :I am the !ocr module, I handle OCRemix functions!","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!ocr [OPTIONAL ocr ID | Text to search for | latest]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalvclass pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()
		globalv.commandCharacter=msg.replace('"','')		return ["PRIVMSG $C$ :Alright, done that!"]	def describe(self, complete):		msg=complete.message()		sender=complete[0].split(' ')		sender=sender[2]		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]# -*- coding: utf-8 -*-
from plugins import plugin
import globalv,sys,os
from pluginHandler import load_plugin, unload_plugin
from aliasHandler import load_alias
import settingsHandler
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        for line in settingsHandler.readSetting("alias","aliasName, aliasPlugin, aliasArguments"):
            load_alias(line[0], ' '.join(line[1:]))

        return ["PRIVMSG $C$ :Ok, done."]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import pluginimport globalvimport sysfrom pluginHandler import load_pluginclass pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		for name in globalv.pluginList:			load_plugin(name)		return ["PRIVMSG $C$ :Ok, done."]	def describe(self, complete):		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]# -*- coding: utf-8 -*-
from plugins import plugin
from settingsHandler import readSetting
from pluginHandler import load_plugin, unload_plugin
from aliasHandler import load_alias
from securityHandler import isAllowed
from userlevelHandler import getLevel
import globalv
import settingsHandler
import sys
import shlex
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 200
    def action(self, complete):
        name=complete.message().split()[0]
        if len(complete.message().split())>1:
            noKill=1
        else:
            noKill=0
        msg="Successfully asked the plugin to stop"
        if isAllowed(complete.userMask())<getLevel(complete.cmd()[0]):
            return ["PRIVMSG $C$ :Only elevated users can do that!"]
        try:
            globalv.loadedInputs[name.split()[0]].set()
            if not noKill:
                settingsHandler.deleteSetting("'core-input'","input",name)
        except Exception as detail:
            msg="Unload failure: "+str(detail)
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !addInput module!","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!addInput [name] [plugin name] [arguments to plugin]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        return ["PRIVMSG $C$ :"+ repr(complete.message()).replace('"',r'\"')]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv, security
class pluginClass(plugin):
	def gettype(self):
		return "command"
	def action(self, complete):
		reload(security)
		globalv.miscVars[2]=security.users()
		return ["PRIVMSG $C$ :"+"Shield integrity restored, now operating at 100% of practical capacity."]
	def describe(self, complete):
		msg=complete.message()
		sender=complete[0].split(' ')
		sender=sender[2]
		return ["PRIVMSG $C$ :I am the !resecure module. I reload user permissions from the database.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!resecure"]# -*- coding: utf-8 -*-
from plugins import plugin
from securityHandler import isAllowed
from userlevelHandler import getLevel
import globalv,re
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 50
    def action(self, complete):
        msg=complete.message()
        nick=complete.userMask()
        sender=complete.channel()
        if msg.split()[1] in globalv.loadedPlugins.keys():
            if isAllowed(nick)>=getLevel(complete.cmd()[0]):
                if msg.split()[1]=="unrestrict":
                    return ["PRIVMSG $C$ :Don't be silly."]
                globalv.accessRights[msg.split()[0]].append(msg.split()[1])
                msg="Ok, restricted that command for that user."
            else:
                msg="Sorry, only administrators can use this command!"
        else:
            msg="Plugin would not appear to exist"
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !restrict module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!restrict [user] [command]"]
# -*- coding: utf-8 -*-
from plugins import pluginimport globalvclass pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()		if msg.split()[0].lower()=="decode":			msg=' '.join(msg.split()[1:]).decode("rot13")		elif msg.split()[0].lower()=="encode":			msg=' '.join(msg.split()[1:]).encode("rot13")		else:			msg=msg.encode("rot13")				return ["PRIVMSG $C$ :"+msg]	def describe(self, complete):		msg=complete.message()		sender=complete[0].split(' ')		sender=sender[2]		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]# -*- coding: utf-8 -*-
from plugins import plugin
import feedparser

import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        #Parse the data, returns a tuple: (data for channels, data for items)
        feed=feedparser.parse(msg)
        return ["PRIVMSG $C$ :Latest entry from "+feed.feed.title+": "+feed.entries[0].title+" (at "+feed.entries[0].link+")"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import pluginfrom settingsHandler import readSettingimport globalvclass pluginClass(plugin):	def __init_db_tables__(self,name):		import settingsHandler		settingsHandler.newTable(name, "filePath", "maxLen")		settingsHandler.writeSetting(name,["filePath","maxLen"],["fortune","300"])	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()		ret=[]		import os		msg=os.popen(readSetting(complete.cmd()[0],"filePath")).read().strip()		for line in msg.split('\n'):			ret.append("PRIVMSG $C$ :"+line)		print msg		if len(msg)>int(readSetting(complete.cmd()[0],"maxLen")):			msg=msg[:int(readSetting(complete.cmd()[0],"maxLen"))]		return ret	def describe(self, complete):		msg=complete.message()		sender=complete[0].split(' ')		sender=sender[2]		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import urllib
import urllib2
from bitlyServ import bitly
import re
import random
import cookielib
import time

class pluginClass(plugin):
    def __init__(self):
        cj = cookielib.CookieJar()
        self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
        r = self.opener.open('http://chan.sankakucomplex.com/en/post/index')

        self.recent = []
        
    def gettype(self):
        return "command"

    def action(self, complete):
        tags = complete.message()
            
        query = urllib.urlencode(dict([["tags",tags]]))
        url = "http://chan.sankakucomplex.com/en/post/index.content?limit=150&"+query

        try:
            req=self.opener.open(url)
        except urllib2.HTTPError as error:
            if '406' in str(error):
                if len(tags.split(' ')) > 4:
                    return ["PRIVMSG $C$ :More than 4 tags are not allowed."]
                if '-' in tags:
                    return ["PRIVMSG $C$ :You may not search for exclusive tags only."]
                
                return ["PRIVMSG $C$ :Unacceptable input (reason unknown)."]
            return ["PRIVMSG $C$ :Sankaku channel seems down!"]
            
        content=req.read()

        pattern = r'href="(.+?)".+?src="(.+?)".+?title="(.+?)"'

        matches = re.findall(pattern, content)

        start = 0
        for u, t in self.recent:
            if t < time.time() - 15 * 60:
                start += 1

        recent = [x for x,y in self.recent[start:]]

        possibilites = []
        
        for href,src,title in matches:
            if not href in recent:
                possibilites.append((href, src, title))

        if possibilites == []:
            return ["PRIVMSG $C$ :No pictures found!"]
        
        match = random.choice(possibilites)

        self.recent.append((match[0], time.time()))

        if match[1].find('download')>-1:
            url = 'http://chan.sankakucomplex.com' + match[0]
        else:
            url = match[1].replace('preview/','')
            url = re.sub('http://c\d','http://chan',url)
            try:
                urllib2.urlopen(url)
            except:
                url = url[:-3] + 'png'
                try:
                    urllib2.urlopen(url)
                except:
                    url = url[:-3] + 'gif'
                    try:
                        urllib2.urlopen(url)
                    except:
                        url = match[0]

        tags = []
        tags_old = match[2].split(' ')
        rating = 'unknown'
        
        for tag in tags_old:
            if tag[:7] == 'rating:':
                rating = tag[7:]
                break
            tags += [tag]

        total_length = 0
        i = 0
        
        for tag in tags:        
            if total_length + len(tag) > 150:
                tags = tags[:i] + ['...']
                break
            i += 1
            total_length += len(tag)
        tags = ' '.join(tags)
        print tags
        
        return ["PRIVMSG $C$ :" + bitly(url) + " (rating: \x02" + rating + "\x02, tags: " + unicode(tags, 'utf-8') + ")"]
    
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !sankaku module! See http://chan.sankakucomplex.com/help/cheatsheet for a full list of features.",
                "PRIVMSG $C$ :Example usage:",
                "PRIVMSG $C$ :!sankaku wallpaper blonde_hair",
                "PRIVMSG $C$ :!sankaku touhou ribbon wings rating:questionable"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        user=complete.channel()
        return ["PRIVMSG $C$ :"+user]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        user=complete.user()
        return ["PRIVMSG $C$ :"+user]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        return ["PRIVMSG $C$ :"+complete.message().decode('utf-8')]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import time
import os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message().strip()
        sender=complete.channel()
        ttime=time.gmtime()
        result=""
        year=time.gmtime()[0]
        day=time.gmtime()[7]
        while not result:
            if not os.path.exists(os.path.join("logs","LogFile - "+sender+"-"+str(year) + "-" + str(day))):
                return ["PRIVMSG $C$ :No matches!"]
            with open(os.path.join("logs","LogFile - "+sender+"-"+str(year) + "-" + str(day))) as file:
                text=file.read()
            text=text.split('\n')
            text.reverse()
            for line in text:
                try:
                    oline=line
                    line=line.split('*')
                    if len(line)==1:
                        line=line[0]
                        if line.find('>')!=-1:
                            line=line.split('>')[1].split()[0]
                        if line.find('<')!=-1:
                            line=line.split('<')[1].split()[0]
                    if len(line)==2:
                        line=line[1].split()[0]
                    else:
                        line=line[1]
                    if line.lower().find(msg.lower())!=-1:
                        print line
                        msgTime=oline.split(']')[0]+"]"
                        nowTime=time.strftime("[%d %b %y %H:%M]")
                        if msgTime!=nowTime:
                            result=oline
                            return ["PRIVMSG $C$ :"+result]
                except:
                    print line,"went badly (Module: seen)"
            day-=1
            if day==0:
                year-=1
                day=365
            print year, day
        return ["PRIVMSG $C$ :"+result]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !seen module. I find out when the last time a user was seen was.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!seen [user]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ :"+msg.capitalize()]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import pluginimport globalv###NOT FIXING THIS. GODDAMN DATABASE IT.class pluginClass(plugin):	def gettype(self):		return "command"	def action(self, complete):		msg=complete.message()		if msg.split()[0]!="USER":			globalv.joinMessages[complete.channel()]=msg			with open("functions\\joinMessages.py","a") as cache:				cache.write("\nglobalv.joinMessages[\""+complete.channel()+"\"]=\""+msg+"\"")		else:			globalv.joinMessages[msg.split()[1].lower()]=' '.join(msg.split()[2:])			with open("functions\\joinMessages.py","a") as cache:				cache.write("\nglobalv.joinMessages[\""+msg.split()[1].lower()+"\"]=\""+' '.join(msg.split()[2:])+"\"")		return ["PRIVMSG $C$ :Ok!"]	def describe(self, complete):		return ["PRIVMSG $C$ :I am the !setJoinMessage module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [OPTIONAL \"USER\" FLAG] message"]# -*- coding: utf-8 -*-
from plugins import plugin
from aliasHandler import save_alias
from userlevelHandler import getLevel
from securityHandler import isAllowed
import settingsHandler
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 100
    def action(self, complete):
        msg=complete.message()
        msgBack=[]
        message=lambda x:msgBack.append("PRIVMSG $C$ :"+x)
        if isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]):
            if msg.split()[0]!="-remove":
                result=save_alias(msg)
                print globalv.loadedAliases.keys()
                if result==1:
                    message("Alias Saved.")
                elif result==2:
                    message("Alias unsuccessful. Alias is already set.")
                else:
                    message("Alias unsuccessful. Make sure you have previously !alias-ed this command")
                    print globalv.loadedAliases.keys()
            else:
                settingsHandler.deleteSetting("alias","aliasName",msg.split()[1])
                message("Alias Removed")
        else:
            message("Alias unsuccessful. This action requires higher priviledges. Use "+globalv.commandCharacter+"alias for temporary aliases.")
        return msgBack
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !set module. I promote aliases. An un-set alias will reset when the bot resets.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!set [alias]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import settingsHandler
from securityHandler import isAllowed
from userlevelHandler import getLevel
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 100
    def action(self, complete):
        msg=complete.message()
        returns="Setting set, cap'n!"
        mode=plugin=setting=set=where=""
        mode=msg.split()[0]
        plugin=msg.split()[1]
        try:
            setting=msg.split()[2]
        except:
            setting=""
        try:
            set=' '.join(msg.split()[3:])
        except:
            set=""
        if len(set.split())<3:
            where = '1==1'
        elif set.split()[-2]=="WHERE":
            where=set.split()[-1]
            set=' '.join(set.split()[:-2])
        else:
            where="1==1"
        if isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]):
            if mode=="update":
                settingsHandler.updateSetting(plugin, setting, set, where=where)
                returns="Setting updated, sir!"
            if mode=="delete":
                settingsHandler.deleteSetting(plugin, setting, set)
                returns="Setting removed, my lord!"
            if mode=="add":
                setting=setting.split('||')
                set=set.split('||')
                settingsHandler.writeSetting(plugin, setting, set)
                returns="Setting Set, Cap'n!"
            if mode=="drop-table":
                settingsHandler.dropTable(plugin)
                returns="Settings lost, comrade!"
            if mode=="list":
                columns=settingsHandler.readColumns(plugin)
                returns=', '.join(columns) 
            if mode=="current":
                results=settingsHandler.readSetting(plugin, setting)
                results=[x[0] if len(x)==1 and type(x)==tuple else x for x in results] if type(results)==list else results
                results=', '.join(results) if type(results)==list else results
                returns=results
            if mode=="commit":
                settingsHandler.db.commit()
                returns="Committed!"
            if mode=="query":
                results=settingsHandler.executeQuery(' '.join(msg.split()[1:]))
                if results!=[]:
                    returns=str(results)
        else:
            returns="Sorry, you can't do this."
        return ["PRIVMSG $C$ :"+returns]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !settings module. I set settings.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!setting [update|add|current|list] [plugin] [OPTIONAL field] [OPTIONAL value] [OPTIONAL WHERE clause"]
# -*- coding: utf-8 -*-
from plugins import plugin
from SMFThreadInformation import SMFThread
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        thread=SMFThread(msg)
        print thread.thread
        msg=thread.thread['thread']['title']+thread.thread['entriesByID'][thread.postID]['name']
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv, urllib2,urllib
import os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        readFile=""
        if msg.find('.')==-1:
            if msg=="OMGbot": msg="../../pyBot"
            for plugindir in ["command","realtime", "postprocess", "preprocess", "input","../functions"]:
                if os.path.exists(os.path.join("plugins", plugindir, msg+".py")):
                    with open(os.path.join("plugins",plugindir,msg+".py")) as file:
                        readFile=file.read()
                        break
            if readFile=="":
                return ["PRIVMSG $C$ :No plugin by that name exists - are you trying to source an alias?"]
            data={"paste_code":readFile}
            data=urllib.urlencode(data)
            req = urllib2.Request("http://pastebin.com/api_public.php", data)
            response = urllib2.urlopen(req)
            msg=response.read()
            return ["PRIVMSG $C$ :"+msg]
        else:
            return ["PRIVMSG $C$ :Incorrect syntax! source [plugin name]"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !source module. I return a pastebin URL with the source of a plugin.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!source [plugin name]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ : "+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from securityHandler import isAllowed
from userlevelHandler import getLevel
import globalv
import re
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 150
    def action(self, complete):
        msg=complete.message()
        blacklist=["quit","part","join","kick","nick","mode"]
        nick=complete.userMask()
        if isAllowed(nick)<getLevel(complete.cmd()[0]):
            return [""] 
        return [msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !special module","PRIVMSG $C$ :Usage: (Requires Elevated Bot Privileges)","PRIVMSG $C$ :!special [raw string]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import time
import os
import shlex
import re
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        ttime=time.gmtime()
        file = open(os.path.join("logs","LogFile - "+complete.channel()+"-"+str(ttime[0]) + "-" + str(ttime[7])))
        lines=file.readlines()
        lines.reverse()
        try:
            toFind=re.compile(shlex.split(complete.message())[0], re.I)
            toReplace=' '.join(shlex.split(complete.message())[1:])
        except Exception as detail:
            return ["PRIVMSG $C$ :%s"%detail]
        print "s starting: Matching %s and replacing with %s"%(toFind.pattern, toReplace)
        for line in lines:
            try:
                line = line.split('*',1)[1] #To cut off the datetime string
            except:
                print line
            if line.split()[1]=="*":
                newLine=line.split('*',1)[1]
            else:
                newLine=line.split(" ",1)[1]
            if toFind.search(newLine) and re.search("^ .*? \* "+globalv.commandCharacter,line) is None:
                if line.split()[1]=="*":
                    isAction=False
                else:
                    isAction=True
                if isAction:
                    user=line.split()[0]
                    line=line[len(user)+2:]
                else:
                    user=line.split()[0]
                    line=line[len(user+" * ")+1:]
                line = toFind.sub(toReplace, line) 
                if isAction:
                    line="* %s %s"%(user,line)
                else:
                    line="<%s> %s"%(user, line)
                return ["PRIVMSG $C$ :%s"%line[:600]]

        return ["PRIVMSG $C$ :Could not find %s in today's logs!"%toFind.pattern]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import time
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        timezones={'FNT': -2, 'AKDT': -8, 'GST': 4, 'CCT': 6, 'LINT': 14, 'BOT': -4, 'EGT': -1, 'CKT': -10, 'DAVT': 7, 'WDT': 9, 'WITA': 8, 'X': -11, 'TMT': 5, 'KUYT': 4, 'Z': 0, 'PETT': 12, 'PDT': -7, 'IOT': 6, 'NZDT': 13, 'MYT': 8, 'HKT': 8, 'PET': -5, 'PMDT': -2, 'NOVST': 7, 'AMST': -3, 'PMST': -3, 'MAWT': 5, 'FJST': 13, 'D': 4, 'HAA': -3, 'HAC': -5, 'HAE': -4, 'BNT': 8, 'HAY': -8, 'T': -7, 'WET': 0, 'HAP': -7,'NZST': 12, 'HAR': -6, 'OMSST': 7, 'HAT': -2, 'BRST': -2, 'PT': -8, 'ANAT': 12,'CXT': 7, 'UYT': -3, 'VLAST': 11, 'HOVT': 7, 'PYT': -4, 'ALMT': 6, 'WT': 0, 'IRKST': 9, 'NPT': 5, 'HNT': -3, 'KST': 9, 'Y': -12, 'EET': 2, 'LHDT': 11, 'VLAT': 10, 'LHST': 10, 'AZST': 5, 'WFT': 12, 'MART': -9, 'PHOT': 13, 'PKT': 5, 'GET': 4, 'YEKT': 5, 'EGST': 0, 'TKT': -10, 'CET': 1, 'EEST': 3, 'SCT': 4, 'AMT': -4, 'ChST': 10, 'C': 3, 'G': 7, 'K': 10, 'O': -2, 'MAGT': 11, 'WGT': -3, 'S': -6, 'NFT': 11, 'W': -10, 'AFT': 4, 'ET': -5, 'MHT': 12, 'BTT': 6, 'HLV': -4, 'YAKST': 10, 'TJT': 5, 'TVT': 12, 'PHT': 8, 'HADT': -9, 'PST': -8, 'HNA': -4, 'MUT': 4, 'HNC': -6, 'GAMT': -9, 'HNE': -5, 'COT': -5, 'IRST': 3, 'UYST': -2, 'IDT': 3, 'AZOST': 0, 'IRDT': 4, 'RET': 4, 'IST': 1, 'HNP': -8, 'VUT': 11, 'HNR': -7, 'CHAST': 12, 'CST': -6, 'HNY': -9, 'FJT': 12, 'IRKT': 8, 'SAST': 2, 'AST': -4, 'BST': 1, 'AZOT': -1, 'NUT': -11, 'JST': 9, 'CAST': 8, 'ANAST': 12, 'ECT': -5, 'MAGST': 12, 'AQTT': 5, 'YAPT': 10, 'EAST': -6, 'TAHT': -10, 'MDT': -6, 'GALT': -6, 'ADT': -3, 'B': 2, 'CLST': -3, 'F': 6, 'OMST': 6, 'CLT': -4, 'N': -1, 'R': -5, 'SRT': -3, 'V': -9, 'GILT': 12, 'WAT': 1, 'NDT': -2, 'GMT': 0, 'WIB': 7, 'SBT': 11, 'PYST': -3, 'MMT': 6, 'BRT': -3, 'YAKT': 9, 'CDT': -5, 'WIT': 9, 'EDT': 11, 'SST': -11, 'WAST': 2, 'NOVT': 6, 'KRAST': 8, 'TFT': 5, 'ULAT': 8, 'KRAT': 7, 'PONT': 11, 'CVT': -1, 'MST': -7, 'VET': -4, 'CAT': 2, 'MSK': 3, 'WST': -11, 'MVT': 5, 'MSD': 4, 'AZT': 4, 'TLT': 9, 'SGT': 8, 'HAST': -10, 'AKST': -9, 'PGT': 10, 'GYT': -4, 'CEST': 2, 'H': 8, 'UZT': 5, 'NST': -3, 'EAT': 3, 'A': 1, 'YEKST': 6, 'EST':-5, 'E': 5, 'PETST': 12, 'I': 9, 'M': 12, 'L': 11, 'Q': -4, 'U': -8, 'CHADT': 13, 'FKST': -3, 'FKT': -4, 'ICT': 7, 'PWT': 9, 'ART': -3, 'KGT': 6, 'P': -3, 'WEST': 1, 'NCT': 11, 'GFT': -3, 'WGST': -2, 'EASST': -5, 'SAMT': 4}
        def isNumber(number):
            try:
                float(number)
                return True
            except ValueError:
                return False
        msg=complete.message()
        timestring=msg
        offset=0
        if len(msg.split())>1:
            offsetString=msg.split()[0]
            if isNumber(offsetString) or offsetString.upper() in timezones:
                if offsetString.upper() in timezones:
                    offset=timezones[offsetString.upper()]
                else:
                    offset=float(offsetString)
                offset=offset*(60*60)
                timestring=' '.join(msg.split()[1:])

        print time.daylight
        return ["PRIVMSG $C$ :%s"%time.strftime(timestring, time.gmtime(time.time()+offset))]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
import shlex
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __append_seperator__(self):
        return True
    def action(self, complete):
        msg=str(complete.message().split('::')[0])
        msg=shlex.split(msg)
        return ["PRIVMSG $C$ :"+re.sub(msg[0],msg[1],str(complete.message().split('::',1)[1]),999).decode('utf-8')]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from securityHandler import isAllowed
from userlevelHandler import getLevel
import settingsHandler
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        if isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]):
            trigger=msg.split()[0]
            command=' '.join(msg.split()[1:])
            try:
                if trigger not in [x[0] for x in settingsHandler.readSettingRaw("'core-expansions'","trigger")]:
                    settingsHandler.writeSetting("'core-expansions'",["trigger","command"],[trigger,command])
                else:
                    settingsHandler.updateSetting("'core-expansions'","command",command,where="trigger='%s'"%trigger)
                msg="%s will now substitute to the output of %s"%(trigger, command)
            except Exception as detail:
                msg="Failure: %s"%detail
        else:
            msg="Sorry, you need to be elevated to use this command!"



        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import time
import re
import os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        today=time.gmtime()
        currentYear=today[0]
        currentDay=today[7]
        users={}
        total=0
        days=5
        numUsers=3
        channel=complete.channel().lower()
        userBlacklist=[]
        userWhitelist=[]
        nextCommand=""
        for command in complete.message().split():
            if nextCommand=="":
                if command=="-days":
                    nextCommand="days"
                elif command.startswith("-nu"):
                    nextCommand="numUsers"
                elif command=="-channel":
                    nextCommand="channel"
                elif command=="-not":
                    nextCommand="blacklist"
                elif command=="-find":
                    nextCommand="whitelist"
                elif command.startswith('-h'):
                    return ["PRIVMSG $C$ :Usage: %s%s [-days Number of days to search] [-num Number of users to return] [-channel Channel to search] [-not Users to exclude] [-find Users to return results for]"%(globalv.commandCharacter, complete.cmd()[0])]
            else:
                if nextCommand=="days":
                    days=int(command)
                elif nextCommand=="numUsers":
                    numUsers=int(command)
                elif nextCommand=="channel":
                    channel=command.lower()
                elif nextCommand=="blacklist":
                    userBlacklist=command.split(',')
                elif nextCommand=="whitelist":
                    userWhitelist=command.split(',')

                nextCommand=""
        for offset in xrange(days):
            day=currentDay-offset
            year=currentYear
            if day <= 0:
                day+=365
                year-=1
            path=os.path.join("logs","LogFile - "+channel+"-"+str(year)+"-"+str(day))
            if not os.path.exists(path):
                continue
            data=open(path).readlines()
            for line in data:
                nickname=re.findall("^\[.*?\]\s\*\s([^\s]*)", line)
                if len(nickname)==0:
                    continue
                nickname=nickname[0]
                if nickname in users:
                    users[nickname]+=1
                else:
                    users[nickname]=1
                total+=1
        userArray=[[key, users[key]] for key in users.keys()]
        userArray.sort(key=lambda x:x[1])
        print userBlacklist
        userArray=filter(lambda x:x[0] not in userBlacklist, userArray)
        if userWhitelist!=[]:
            userArray=filter(lambda x:x[0] in userWhitelist, userArray)
        toReturn="PRIVMSG $C$ :%s total lines from the past %s days! Rankings:"%(total, days)
        for index in range(1,min(numUsers+1,len(userArray)+1)):
            numLines=userArray[-index][1]
            name=userArray[-index][0]
            percentage=(numLines/float(total))*100
            if percentage>1:
                percentage=int(percentage)
            toReturn+=" %s with %s%% of the chat (%s lines);"%(name, percentage, numLines)
        return [toReturn]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from pluginArguments import pluginArguments
from pluginFormatter import formatInput, formatOutput
import globalv
import operator
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        argumentString = ":null!nobody@nowhere PRIVMSG nothing :!sr388"
        argumentsObject = formatInput(pluginArguments(argumentString))
        numbers={}
        if complete.message().isdigit()==False:
            totalIterations = 10000
        else:
            totalIterations=int(complete.message())
        for i in xrange(0,totalIterations):
            output = globalv.loadedPlugins['sr388'].action(argumentsObject)[0]
            number = output.split()[3][1:]
            if number in numbers:
                numbers[number]+=1
            else:
                numbers[number]=1
        sortedNumbers = sorted(numbers.iteritems(), key=operator.itemgetter(1))
        sortedNumbers.reverse()
        minHits=(0, totalIterations)
        maxHits=(0,0)
        total=0
        for number in sortedNumbers:
            total+=number[1]
        mean = total/len(sortedNumbers)
        devTotal=0

        for number in sortedNumbers:
            devTotal+= (number[1]-mean)**2
            if number[1]>maxHits[1]:
                maxHits = number
            elif number[1]<minHits[1]:
                minHits = number

        devMean = devTotal/len(sortedNumbers)
        stdDev = devMean**0.5


        return ["PRIVMSG $C$ :Total iterations: %s; Most often picked quote: %s (with %s hits); Least often picked quote: %s (with %s hits); Results have a standard devation of %s"%(totalIterations, maxHits[0], maxHits[1], minHits[0], minHits[1], stdDev)]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
from securityHandler import isAllowed
from userlevelHandler import getLevel
import difflib
import settingsHandler
class pluginClass(plugin):
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name,"key","value")
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        returner=""
        elevated = getLevel(complete.userMask()) >= isAllowed(complete.cmd()[0])
        if msg=="":
            returner="This is the %s dictionary. Run !%s -list for a list of known values!"%(complete.cmd()[0], complete.cmd()[0])
        elif msg.split()[0]=="-add" and elevated:
            settingsHandler.writeSetting(complete.cmd()[0],["key","value"], [msg.split()[1],' '.join(msg.split()[2:])])
            returner="Key:Value pair added!"
        elif msg.split()[0]=="-delete" and elevated:
            settingsHandler.deleteSetting(complete.cmd()[0],"key",msg.split()[1])
            returner="Key removed!"
        elif msg.split()[0]=="-list":
            keypairs=[x[0] for x in settingsHandler.readSettingRaw(complete.cmd()[0],"key")]
            returner=', '.join(keypairs)
        elif msg.split()[0]=="-random":
            keypairs=settingsHandler.readSettingRaw(complete.cmd()[0],"key, value")
            pairs={}
            for keypair in keypairs:
                pairs[keypair[0].lower()]=keypair[1]
            import random
            keys=pairs.keys()
            random.shuffle(keys)
            returner=keys[0]+": "+pairs[keys[0]]
        else:
            keypairs=settingsHandler.readSettingRaw(complete.cmd()[0],"key, value")
            pairs={}
            for keypair in keypairs:
                pairs[keypair[0].lower()]=keypair[1]
            if unicode(msg.split()[0]).lower() in pairs.keys():
                returner=pairs[unicode(msg.split()[0]).lower()]
            elif "default" not in pairs.keys():
                returner="No definition."
                matches=difflib.get_close_matches(msg.split()[0],pairs.keys(),10,0.1)
                if len(matches)>0:
                    returner+=" Perhaps you meant: "+', '.join(matches[:-1])
                    if len(matches)>1:
                        returner+=" or "+matches[-1]
                else:
                    returner+=" No similar definitions"
            else:
                returner=pairs['default']
        if returner=="":
            return [""]
        return ["PRIVMSG $C$ :"+returner]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !text2text module. I provide simple dictionary lookups.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!text2text [-add|-delete|-list] key [definition]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv

class AlreadyAPieceThereException(Exception):
		def __init__(self):
			pass
		def __str__(self):
			return "Piece already there!"


class TicTacToe(object):
	def __init__(self,XUser,OUser):
		self.board=[" "]*9
		self.Users=[XUser,OUser]
		
	def setBit(self,where,what):
		numbers="x678345012"
		where=int(numbers[int(where)])
		if what.lower()=="x" or what.lower()=="o":
			if self.board[where]==" ":
				self.board[where]=what
			else:
				raise AlreadyAPieceThereException
	def checkFinished(self):
		finishedArray=[[0,1,2],[3,4,5],[6,7,8], # vertical
						[0,3,6],[1,4,7],[2,5,8], # horizontal
						[0,4,8],[2,4,6]] #Diagonal
		finished=0
		for check in finishedArray:
			if self.board[check[0]]==self.board[check[1]]==self.board[check[2]]:
				if self.board[check[0]]!=" ":
					finished=1
				
		return finished
	def printState(self,turn):
		board=self.board
		state=['PRIVMSG $C$ :'+'|'.join(board[0:3]),'PRIVMSG $C$ :'+'|'.join(board[3:6]),'PRIVMSG $C$ :'+'|'.join(board[6:9]),'PRIVMSG $C$ :It is now '+self.User(turn)+"'s turn"]
		return state
	def User(self,turn):
		if turn=="X":
			return self.Users[0]
		else:
			return self.Users[1]
			
class pluginClass(plugin):
	def gettype(self):
		return "command"
	import random

	def __init__(self):
		self.currentGame=TicTacToe("PY","OMGbot")
		self.turn="X"
		self.isDone=1
	def action(self, complete):
		msg=complete.message()
		nick=complete.user()
		moves=[str(i+1) for i in range(9)]
		X="X"
		O="O"
		if msg.split()[0:2]==["new","game"]:
			try:
				self.currentGame=TicTacToe(msg.split()[2],msg.split()[3])
				self.turn="X"
				self.isDone=0
				msg="Ok, it's "+msg.split()[2]+"'s go!"
			except:
				msg="Needs two user names!"
		if not self.isDone:
			if msg in moves:
				print nick, self.currentGame.User(self.turn)
				if nick==self.currentGame.User(self.turn):
					move=int(msg)
					try:
						self.currentGame.setBit(int(move),self.turn)
						msg="ok! Set position "+str(move)+" to "+self.turn
						if self.turn==X:
							self.turn=O
						else:
							self.turn=X
						if self.currentGame.checkFinished():
							if self.turn==X:
								nturn=O
							else:
								nturn=X
							msg="Well done, "+self.currentGame.User(nturn)+", you won!"
							self.isDone=1
							return ["PRIVMSG $C$ :"+msg]
						return self.currentGame.printState(self.turn)
					except Exception as detail:
						msg="Space already taken."
						print detail
				else:
					msg="No, silly, it's "+self.currentGame.User(self.turn)+"'s turn. let them go."
			elif msg=="check":
				return self.currentGame.printState(self.turn)
		else:
			msg="No game in progress. Syntax: TicTacToe new game [player 1] [player 2]"
		return ["PRIVMSG $C$ :"+msg]
	def describe(self, complete):
		return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
from securityHandler import isAllowed
from userlevelHandler import getLevel
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 50
    def action(self, complete):
        msg=complete.message()
        sender=complete.channel()
        globalv.variables['lasttopic']=globalv.miscVars[4][complete.channel()][0]
        if isAllowed(complete.userMask())<getLevel(complete.cmd()[0]) and len(msg)!=0:
            return [""]
        if msg=="":
            return ["PRIVMSG $C$ :"+' '.join(globalv.miscVars[4][sender])]
        if msg.split()[0]=="add":
            return ["TOPIC $C$ :"+' '.join(globalv.miscVars[4][sender])+" | "+' '.join(msg.split()[1:])]
        elif msg.split()[0]=="remove":
            return ["TOPIC $C$ :"+' | '.join(' '.join(globalv.miscVars[4][sender]).split(' | ')[:-int(msg.split()[1])])]
        else:
            return["TOPIC $C$ :"+msg]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !topic module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!topic [OPTIONAL add/remove] [text/number of sections to remove]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=[x for x in str(complete.message())]
        file=open(os.path.join("config","russian.txt"),'r').read()
        file=file.split('\n\n\n')
        lowercase=file[0].split('\n\n')
        lowercase=[x.split('\n') for x in lowercase]
        uppercase=file[1].split('\n\n')
        uppercase=[x.split('\n') for x in uppercase]
        print lowercase
        for letter in range(len(msg)):
            if msg[letter] in lowercase[0]:
                msg[letter]=lowercase[1][lowercase[0].index(msg[letter])]
            if msg[letter] in uppercase[0]:
                msg[letter]=uppercase[1][uppercase[0].index(msg[letter])]
        print msg
        return ["PRIVMSG $C$ :"+''.join(msg).decode('utf-8')]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import urllib2
import urllib
import shlex
import re


class pluginClass(plugin):
    def __init__(self):
        self.langTable = [('Afrikaans', 'af'),
                          ('Albanian', 'sq'),
                          ('Arabic', 'ar'),
                          ('Armenian', 'hy'),
                          ('Azerbaijani', 'az'),
                          ('Basque', 'eu'),
                          ('Belarusian', 'be'),
                          ('Bulgarian', 'bg'),
                          ('Catalan', 'ca'),
                          ('Croatian', 'hr'),
                          ('Czech', 'cs'),
                          ('Danish', 'da'),
                          ('Dutch', 'nl'),
                          ('English', 'en'),
                          ('Estonian', 'et'),
                          ('Filipino', 'tl'),
                          ('Finnish', 'fi'),
                          ('French', 'fr'),
                          ('Galician', 'gl'),
                          ('Georgian', 'ka'),
                          ('German', 'de'),
                          ('Greek', 'el'),
                          ('Haitian Creole', 'ht'),
                          ('Hebrew', 'iw'),
                          ('Hindi', 'hi'),
                          ('Hungarian', 'hu'),
                          ('Icelandic', 'is'),
                          ('Indonesian', 'id'),
                          ('Irish', 'ga'),
                          ('Italian', 'it'),
                          ('Japanese', 'ja'),
                          ('Korean', 'ko'),
                          ('Latin', 'la'),
                          ('Latvian', 'lv'),
                          ('Lithuanian', 'lt'),
                          ('Macedonian', 'mk'),
                          ('Malay', 'ms'),
                          ('Maltese', 'mt'),
                          ('Norwegian', 'no'),
                          ('Persian', 'fa'),
                          ('Polish', 'pl'),
                          ('Portuguese', 'pt'),
                          ('Romanian', 'ro'),
                          ('Russian', 'ru'),
                          ('Serbian', 'sr'),
                          ('Slovak', 'sk'),
                          ('Slovenian', 'sl'),
                          ('Spanish', 'es'),
                          ('Swahili', 'sw'),
                          ('Swedish', 'sv'),
                          ('Thai', 'th'),
                          ('Turkish', 'tr'),
                          ('Ukrainian', 'uk'),
                          ('Urdu', 'ur'),
                          ('Vietnamese', 'vi'),
                          ('Welsh', 'cy'),
                          ('Yiddish', 'yi')]

    def gettype(self):
        return "command"

    def action(self, complete):
        msg=str(complete.message()); #######

        print msg

        if (msg == ""):
            return ["PRIVMSG $C$ :Invalid Parameters"]

        args = shlex.split(msg)

        if (len(args) != 1 and len(args) != 3 and len(args) != 5):
            return ["PRIVMSG $C$ :Invalid Parameters (Wrong number of arguments)"]

        langFrom = ""
        langTo = "en"

        if (len(args) >= 3):
            args[1]=str(args[1])
            if (args[1] == "to"):
                langTo=""
                for x in self.langTable:
                    if (x[0].lower()==args[2].lower()):
                        langTo=x[1]
                        break
                if (langTo==""):
                    return ["PRIVMSG $C$ :Cannot translate to " + args[2] + ", sorry!"]
            elif (args[1] == "from"):
                langFrom=""
                for x in self.langTable:
                    if (x[0].lower()==args[2].lower()):
                        langFrom=x[1]
                        break
                if (langTo==""):
                    return ["PRIVMSG $C$ :Cannot translate to " + args[2] + ", sorry!"]
            else:
                return ["PRIVMSG $C$ :Invalid Parameters (Use double quotes (\") to translate a sentence.)"]

        if (len(args) == 5):
            if (args[3] == args[2]):
                return ["PRIVMSG $C$ :Invalid Parameters (Args 3 and 2 are identical)"]
            if (args[3] == "to"):
                langTo=""
                for x in self.langTable:
                    if (x[0].lower()==args[4].lower()):
                        langTo=x[1]
                        break
                if (langTo==""):
                    return ["PRIVMSG $C$ :Cannot translate to " + args[4] + ", sorry!"]
            elif (args[3] == "from"):
                langFrom=""
                for x in self.langTable:
                    if (x[0].lower()==args[4].lower()):
                        langFrom=x[1]
                        break
                if (langTo==""):
                    return ["PRIVMSG $C$ :Cannot translate to " + args[4] + ", sorry!"]
            else:
                return ["PRIVMSG $C$ :Invalid Parameters (Use double quotes (\") to translate a sentence.)"]

        #text = unicode(args[0], 'utf-8')
        #query = urllib.urlencode(dict([["q",text.encode('utf-8')]]))
        query = urllib.urlencode(dict([["q",args[0]]]))
        url = "http://www.google.com/uds/Gtranslate?callback=google.language.callbacks.id101&context=22&langpair="+langFrom+"|"+langTo+"&key=notsupplied&v=1.0&"+query

        req=urllib2.urlopen(url)
        content=req.read()

        encoding=req.headers['content-type'].split('charset=')[-1]
        ucontent = unicode(content, encoding)

        start = ucontent.find('"translatedText":"') + 18
        if (langFrom==""):
            end = ucontent.find('","det')
            if (end==-1):
                if (ucontent.find('could not reliably detect source language')>-1):
                    return ["PRIVMSG $C$ :Could not reliably detect source language."]
                else:
                    return ["PRIVMSG $C$ :Translation failure! :("]
            detectedLang = ucontent[end+28:end+30]

        else:
            end = ucontent.find('"}')
            detectedLang = langFrom

        langFrom="an unknown language"
        for x in self.langTable:
            if (x[1]==detectedLang):
                langFrom=x[0]
                break

        translation = ucontent[start:end]
        print translation

        return ["PRIVMSG $C$ :" + translation + " (translated from "+langFrom[0].capitalize()+langFrom[1:]+")"]


    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !translate module",
                "PRIVMSG $C$ :Example usage:",
                "PRIVMSG $C$ :!translate \"The cake is a lie!\" to German",
                "PRIVMSG $C$ :!translate \"Mark Borgerding died for our sins!\" to Italian",
                "PRIVMSG $C$ :!translate \"Het is meer dan negenduizend!\""]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
import urllib
import urllib2
import xml.sax.saxutils
import mimetypes
def fixXMLEntities(match):
    value=int(match.group()[2:-1])
    return chr(value)
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        logindata={'email':"AHPhoshi@gmail.com", "password":"11235813","type":"quote", "tags":complete.channel()}
        message=complete.message()
        if len(message.split())>1:
            if message.split()[-2].lower()=="-by":
                name=message.split()[-1]
                message=' '.join(message.split()[:-2])
            else:
                name=""
        logindata.update({"quote":message})
        if name!="":
            logindata.update({"source":name})
        uploadData=urllib.urlencode(logindata)
        req=urllib2.Request("http://www.tumblr.com/api/write",uploadData)
        con=urllib2.urlopen(req)
        return ["PRIVMSG $C$ :Added that post."]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the plugin that follows URLs","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :None - I monitor all input, if you have a url in your text, I will find it."]
from plugins import plugin
from bitlyServ import bitly

import re
import wave
import math

class pluginClass( plugin ):
    def gettype(self):
        return "command"
    
    def __init__(self):
        self.functions = {'sine':self.sine,
                          'triangle':self.triangle,
                          'square':self.square,
                          'saw':self.sawup,
                          'sawup':self.sawup,
                          'sawdown':self.sawdown
                          }
        
        self.re_settings = re.compile('(%s)?\s*(\d+)?[.+o-]' % ('|'.join(self.functions.keys())))
        self.re_term = re.compile('(?P<duration>[.+o-]+)(?P<notes>((?:[a-g][b#]?[1-8]|#))+)')
        self.re_init = re.compile('([.+o-]+(?:[^.+o-]|\s)+)\s*')
        self.re_note = re.compile('[a-g][b#]?[1-8]')
        self.deltas = {}

        self.framerate = 22050

        self.deltas['#'] = 0

        for i in range(1,8):
            oc = str(i)
            ocf = 13.75 * (2 ** i)
            self.deltas['c' + oc]  = ocf * (2 ** (3/12.0)) / self.framerate
            
            self.deltas['c#' + oc] = ocf * (2 ** (4/12.0)) / self.framerate
            self.deltas['db' + oc] = self.deltas['c#' + oc]
            
            self.deltas['d' + oc]  = ocf * (2 ** (5/12.0)) / self.framerate
            
            self.deltas['d#' + oc] = ocf * (2 ** (6/12.0)) / self.framerate
            self.deltas['eb' + oc] = self.deltas['d#' + oc]
            
            self.deltas['e' + oc]  = ocf * (2 ** (7/12.0)) / self.framerate
            
            self.deltas['f' + oc]  = ocf * (2 ** (8/12.0)) / self.framerate
            
            self.deltas['f#' + oc] = ocf * (2 ** (9/12.0)) / self.framerate
            self.deltas['gb' + oc] = self.deltas['f#' + oc]
            
            self.deltas['g' + oc]  = ocf * (2 ** (10/12.0)) / self.framerate
            
            self.deltas['g#' + oc] = ocf * (2 ** (11/12.0)) / self.framerate
            self.deltas['ab' + oc] = self.deltas['g#' + oc]
            
            self.deltas['a' + oc]  = 2 * ocf / self.framerate

            self.deltas['a#' + oc] = 2 * ocf * (2 ** (1/12.0)) / self.framerate
            self.deltas['bb' + oc] = self.deltas['a#' + oc]
            
            self.deltas['b' + oc]  = 2 * ocf * (2 ** (2/12.0)) / self.framerate

    def sine(self, phase):
        return math.sin(phase * 2 * math.pi)

    def square(self, phase):
        return (1 if phase < 0.5 else -1)

    def triangle(self, phase):
        if phase < 0.5:
            return -1+phase*4
        else:
            return 1-(phase-0.5)*4

    def sawup(self, phase):
        return phase*2-1

    def sawdown(self, phase):
        return 1-phase*2

    def action(self, complete):
        m = complete.message().lower()

        fileName = complete.user() + '.wav'

        settings = self.re_settings.match(m)
        if settings:
            if settings.group(1) and settings.group(1) in self.functions:
                f = self.functions[settings.group(1)]
            else:
                f = self.triangle
                
            if settings.group(2):
                bpm = int(settings.group(2))
            else:
                bpm = 120
        else:
            f = self.triangle
            bpm = 120

        speed = 60.0 * self.framerate / (bpm * 4)

        if speed < 300:
            return ["PRIVMSG $C$ :Range error: too fast."]
        
        terms = self.re_init.findall(m)

        if len(terms) == 0:
            return ["PRIVMSG $C$ :Parsing error: please revise your tune."]

        data = ''

        d = {}

        currentlyPlaying = []

        for note in self.deltas:
            d[note] = 0

        length = 0

        durations = {}
        termnotes = {}

        for term in terms:
            m = self.re_term.match(term)
            if m == None:
                return ["PRIVMSG $C$ :Error: Could not parse term %s" % term]
            
            notes = self.re_note.findall(term)

            for note in notes:
                if not note in d:
                    return ["PRIVMSG $C$ :Error: Note %s not supported." % note]

            termnotes[term] = set(notes)
            
            duration = 0
            for c in m.group('duration'):
                if c == '.':
                    duration += 1
                elif c == '-':
                    duration += 2
                elif c == '+':
                    duration += 4
                elif c == 'o':
                    duration += 8
            durations[term] = duration

            length += duration * speed

        if length > 2300000:
            return ["PRIVMSG $C$ :Error: estimated file size too large."]
            
        for term in terms:
            duration = durations[term]
            notes = termnotes[term]
            
            m = self.re_term.match(term)

            i = 0

            for note in d:
                if not note in notes:
                    d[note] = 0

            fade = 1
            while i < duration * speed:
                a = 0
                for note in notes:
                    d[note] += self.deltas[note]
                    if d[note] > 1:
                        d[note] -= 1
                    a += f(d[note])

                a = min(max(int(32767.5 * a * fade / 4),-32768),32767)
                
                data += wave.struct.pack('h', a)
                i += 1
                fade -= 0.00001
                if fade < 0:
                    fade = 0
                            
        w = wave.open('/home/py/public_html/tunes/' + fileName, 'wb')
        w.setframerate(self.framerate)
        w.setnchannels(1)
        w.setsampwidth(2)
        w.writeframes(data)
        w.close()

        return ['PRIVMSG $C$ :' + bitly('http://terminus.mrflea.net:81/~py/tunes/' + fileName)]

    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !tune module. ",
                "PRIVMSG $C$ :To create a tune, the argument string has to have the following format:",
                "PRIVMSG $C$ :tune = ['sine'|'square'|'triangle'][bpm](duration note octave)+",
                "PRIVMSG $C$ :BPM is optional (default value of 120)",
                "PRIVMSG $C$ :duration is a sum of symbols: .-+o would mean '.' (1/16th) + '-' (1/8th) + '+' (1/4th) + 'o' (half) = note length of 15/16th ",
                "PRIVMSG $C$ :note is one of the following values: A, A#, Bb, C, C#, Db, D, D#, Eb, E, F, F#, G, G#, Ab",
                "PRIVMSG $C$ :octave has to lie in the range [1,7] - from C1 to B7"
                ]
            
                
# -*- coding: utf-8 -*-
from plugins import plugin
from securityHandler import isAllowed
from userlevelHandler import getLevel
import re
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 100
    def action(self, complete):
        msg=complete.message()
        if isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]):
            if msg in globalv.miscVars[0].keys():
                msg=globalv.miscVars[0][msg]
            return ['MODE $C$ -b '+msg]
        else:
            return [""]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !unban module. I un-banish people.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!unban [user] (Hostmasks are stored locally)"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import os
import settingsHandler
import difflib
from securityHandler import isAllowed
from userlevelHandler import getLevel
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 50
    def action(self, complete):
        msg=complete.message()
        amsg=msg
        if isAllowed(complete.userMask())<getLevel(complete.cmd()[0]):
            return ["PRIVMSG $C$ :No."]
        if msg=="*":
            #settingsHandler.deleteSetting("coreIgnorance","1","1")
            settingsHandler.dropTable("coreIgnorance")
            settingsHandler.newTable("coreIgnorance","ignorance","nickname")
            return ["PRIVMSG $C$ :Unignored everything, my lord"]
        if msg in globalv.miscVars[0]:
            msg=globalv.miscVars[0][msg]
        try:
            print amsg
            print [x[0] for x in settingsHandler.readSettingRaw("coreIgnorance","ignorance")]
            if amsg in [x[0] for x in settingsHandler.readSettingRaw("coreIgnorance","ignorance")]:
                settingsHandler.deleteSetting("coreIgnorance","ignorance",amsg)
            msg=".*@"+msg.split('@')[1] if msg.find('@')!=-1 else msg
            print msg
            if msg in [x[0] for x in settingsHandler.readSettingRaw("coreIgnorance","ignorance")]:
                settingsHandler.deleteSetting("coreIgnorance","ignorance",msg)
                return ["PRIVMSG $C$ :"+amsg + " successfully unignored, cap'n!"]
            else:
                matches=difflib.get_close_matches(msg,[x[0] for x in settingsHandler.readSettingRaw("coreIgnorance","ignorance")],3,0.4)
                matches=["None"] if matches==[] else matches
                globalv.variables['ignored']=matches[0]
                return ["PRIVMSG $C$ :"+msg+" is not ignored, commander! Near matches: "+', '.join(matches)+". ~ignored~ set to nearest match."]
        except Exception as detail:
            return ["PRIVMSG $C$ :"+msg+" not unignored: "+str(detail)]
        return ["PRIVMSG $C$ :"+amsg + " successfully unignored, cap'n!"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !unignore module. Unlike !ignore, anybody can use me, except those who are ignored.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!unignore [regex-hostmask]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv,glob,os
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        ignoreThese=["aliases","blank","globalv","plugins","security","bitlyServ"]
        files=[]
        for file in glob.glob(os.path.join("plugins","*.py")):
            file=file.split(os.path.sep)[1].split('.')[0]
            if (file not in globalv.loadedPlugins.keys() and file not in globalv.loadedRealtime.keys() and file not in globalv.loadedSpecial.keys() and file not in ignoreThese):
                files.append(file)
        return ["PRIVMSG $C$ :Currently unloaded plugins are: "+', '.join(files)]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !unloaded module, I list plugins that aren't loaded - but could be.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!unloaded"]
# -*- coding: utf-8 -*-
from plugins import plugin
from settingsHandler import readSetting
from pluginHandler import unload_plugin
from securityHandler import isAllowed
from userlevelHandler import getLevel
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 100
    def action(self, complete):
        msg=complete.message()
        name=msg.split()[0]
        if isAllowed(complete.userMask())<getLevel(complete.cmd()[0]):
            return ["PRIVMSG $C$ :Sorry, only elevated users can do that!"]
        if name=="load" and complete[0].split()[0].split('!')[0]!=readSetting("core","username"):
            return ["PRIVMSG $C$ :Silly bugger, that would break the world!"]
        success=unload_plugin(name)
        if name in globalv.loadedAliases.keys():
            del globalv.loadedAliases[name]
        if msg.split()[1:]==['silently']:
            return [""]
        if success:
            return ["PRIVMSG $C$ :Unload successful!"]
        else:
            return ["PRIVMSG $C$ :Plugin is not loaded!"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import re
from securityHandler import isAllowed
from userlevelHandler import getLevel
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 100
    def action(self, complete):
        msg=complete.message()
        nick=complete.userMask()
        if isAllowed(nick)>=getLevel(complete.cmd()[0]):
            if msg.split()[1] in globalv.accessRights[msg.split()[0]]:
                globalv.accessRights[msg.split()[0]].remove(msg.split()[1])
                msg="Ok, removed that restriction."
            else:
                msg="That user can already use that command!"
        else:
            msg="Sorry, only administrators can use this command!"
        return ["PRIVMSG $C$ :"+msg]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from settingsHandler import readSetting
from userlevelHandler import getLevel
from securityHandler import isAllowed
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 200
    def action(self, complete):
        msg=complete.message()
        sender=complete.user()
        if isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]):
            globalv.miscVars[2].append(msg)
            import random
            msg="LOWERING SHIELDS TO "+str(random.randint(0,100))+"%"
            return ["PRIVMSG $C$ :"+msg]
        else:
            return ["PRIVMSG $C$ :Don't be silly, only administrators can do that, $U$."]
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ :"+msg.upper()]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import time
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        user=msg.split()[0] if len(msg.split())>0 else complete.user()
        if user[0]=='#':
            for cuser in globalv.channelUsers[complete.channel()]:
                globalv.timeUsers[cuser]=complete.channel()
        globalv.timeUsers[user]=complete.channel()
        return ["PRIVMSG "+user+" :PING %s"%time.time()]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !time module. I return a user's local time.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!time [user]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        user=msg.split()[0] if len(msg.split())>0 else complete.user()
        if user[0]=='#':
            for cuser in globalv.channelUsers[complete.channel()]:
                globalv.timeUsers[cuser]=complete.channel()
        globalv.timeUsers[user]=complete.channel()
        return ["PRIVMSG "+user+" :TIME"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !time module. I return a user's local time.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!time [user]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import pickle
import os
from securityHandler import isAllowed
from userlevelHandler import getLevel
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message().split()
        if len(msg)>1:
            if isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]):
                try:
                    globalv.variables[msg[0]]=eval(' '.join(msg[1:]),{},{})
                    with open(os.path.join("config","variables"),'w') as file:
                        pickle.dump(globalv.variables,file,pickle.HIGHEST_PROTOCOL)
                except Exception as detail:
                    return ["PRIVMSG $C$ :Variable setting failure with expression %s: %s"%(' '.join(msg[1:]), detail)]

        else:
            if msg[0] in globalv.variables.keys():
                return ["PRIVMSG $C$ :%s"%globalv.variables[msg[0]]]
            else:
                return ["PRIVMSG $C$ :Undefined"]
        return [""]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
	def gettype(self):
		return "command"
	def action(self, complete):
		msg=complete.message()
		globalv.timeUsers[msg.split()[0]]=complete.channel()
		print globalv.timeUsers
		return ["PRIVMSG "+msg.split()[0]+" :VERSION"]
	def describe(self, complete):
		return ["PRIVMSG $c$ :I am the !time module. I return a user's local time.","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!time [user]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
import random
import settingsHandler
from pluginFormatter import formatInput
from pluginArguments import pluginArguments
from userlevelHandler import getLevel
from securityHandler import isAllowed
import re
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __init__(self):
        self.Voted={}
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name, "votes","plugin")
        settingsHandler.writeSetting(name,["votes","plugin"],["3","9"])
    def action(self, complete):
        msg=complete.message()
        votes=int(settingsHandler.readSetting(complete.cmd()[0], "votes"))
        plugin=settingsHandler.readSetting(complete.cmd()[0], "plugin")
        user=complete.userMask().split('!')[1]
        if msg.lower() in self.Voted.keys():
            if user in self.Voted[msg.lower()]:
                return ["PRIVMSG $C$ :You have already voted!"]
            else:
                self.Voted[msg.lower()].append(user)
                numRequired=votes-len(self.Voted[msg.lower()])
                if numRequired>0:
                    if msg!="":
                        msg=" "+msg
                    if numRequired!=1:
                        s="s"
                    else:
                        s=""
                    return ["PRIVMSG $C$ :Voted to %s%s. %s more vote%s required."%(plugin,msg,numRequired,s)]
        else:
            self.Voted[msg.lower()]=[user]
            numRequired=votes-len(self.Voted[msg.lower()])
            if msg!="":
                msg=" "+msg
            if numRequired!=1:
                s="s"
            else:
                s=""
            return ["PRIVMSG $C$ :Voted to %s%s. %s more vote%s required."%(plugin,msg,numRequired,s)]
        if len(self.Voted[msg.lower()])>=votes:
            input=":%s!%s PRIVMSG %s :!%s %s"%(globalv.nickname,globalv.miscVars[0][globalv.nickname],complete.channel(),plugin, msg)
            inputObj=formatInput(pluginArguments(input))
            output=globalv.loadedPlugins[plugin.split()[0]].action(inputObj)
            self.Voted[msg.lower()]=[]
            return output
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !kick module","PRIVMSG $C$ :Usage: (Requires Elevated Bot Privileges)","PRIVMSG $C$ :!kick [user]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from userlevelHandler import getLevel
from securityHandler import isAllowed
import globalv
import os
import settingsHandler
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __level__(self):
        return 150
    def __init_db_tables__(self, name):
        settingsHandler.newTable(name, "location")
        settingsHandler.writeSetting(name, "location","/home/py/")
    def action(self, complete):
        if isAllowed(complete.userMask())>=getLevel(complete.cmd()[0]):
            url=complete.message()
            location=settingsHandler.readSetting(complete.cmd()[0],"location")
            wgetString="wget -N --directory-prefix=%s %s &"%(location, url)
            print wgetString
            os.system(wgetString)
            return ["PRIVMSG $C$ :Downloading %s to %s."%(url, location)]
        else:
            return ["PRIVMSG $C$ :Sorry, you need higher priviledges to download files!"]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
import globalv
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def action(self, complete):
        msg=complete.message()
        return ["PRIVMSG $C$ :"+msg[::-1]]
    def describe(self, complete):
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
# -*- coding: utf-8 -*-
from plugins import plugin
from settingsHandler import readSetting
import globalv
import subprocess
import shlex
import urllib, urllib2
import os
import pexpect
from time import sleep
class pluginClass(plugin):
    def gettype(self):
        return "command"
    def __init__(self):
        init="/home/py/frotz/bin/dfrotz /home/py/frotz/bin/ZORK1.DAT"
        args=shlex.split(init)
        #self.zork=subprocesses.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        self.zork=pexpect.spawn(init)
        self.scrollback=""

    def action(self, complete):
        msg=complete.message()
        if msg=="scrollback":
            data={"paste_code":self.scrollback,"paste_private":1,"paste_expire_date":"1H"}
            data=urllib.urlencode(data)
            req = urllib2.Request("http://pastebin.com/api_public.php", data)
            response = urllib2.urlopen(req)
            msg=response.read()
            return ["PRIVMSG $C$ :%s"%msg]

        else:
            over=False
            self.zork.sendline(msg)
            output=""
            while not over:
                try:
                    self.zork.expect('\r\n',timeout=2)
                    output+="\n"+self.zork.before
                    print output
                except Exception as detail:
                    print detail
                    over=True
            ret=[]
            self.scrollback+=output
            for line in output.split('\n'): # 0 is stdout
                if line!="":
                    ret.append("PRIVMSG $C$ :"+line)
            return ret
    def describe(self, complete):
        msg=complete.message()
        sender=complete[0].split(' ')
        sender=sender[2]
        return ["PRIVMSG $C$ :I am the !say module","PRIVMSG $C$ :Usage:","PRIVMSG $C$ :!say [input]"]
